\documentclass{scrreprt}
\usepackage{listings}
\usepackage{underscore}
\usepackage[francais]{babel}
\usepackage[utf8]{inputenc}
\usepackage[bookmarks=true]{hyperref}
\usepackage{tabularx}

\hypersetup{
    bookmarks=false, % show bookmarks bar?
    pdftitle={Document de spécification des exigences du logiciel}
pdfauthor={Jean-Philippe Caissy\\Stéphan Michaud\\Guillaume Auger\\Maxime
Bélanger\\Justin Michaud-Ouelette\\Frédéric Sevillano}
%pdfsubject={TeX and LaTeX}, % subject of the document %pdfkeywords={TeX, LaTeX, graphics, images}, % list of keywords
    colorlinks=true, % false: boxed links; true: colored links
    linkcolor=blue, % color of internal links
    citecolor=black, % color of links to bibliography
    filecolor=black, % color of file links
    urlcolor=purple, % color of external links
    linktoc=page % only page is linked
}%
\def\myversion{1.0 }
\title{%
\flushright
\rule{16cm}{5pt}\vskip1cm
\Huge{Document de spécification des exigences du logiciel}\\
\vspace{2cm}
pour\\
\vspace{2cm}
Nitcorn\\
\vspace{2cm}
%\LARGE{Release 1.0\\}
%\vspace{2cm}
%\LARGE{Version \myversion approved\\}
%\vspace{2cm}
Préparé par Jean-Philippe Caissy\\Stéphan Michaud\\Guillaume Auger\\Maxime
Bélanger\\Justin Michaud-Ouelette\\Frédéric Sevillano\\
\vfill
\rule{16cm}{5pt}
}
\date{}
\usepackage{hyperref}
\begin{document}
\maketitle
\tableofcontents
\chapter*{Historique de révision}
\begin{tabularx}{\textwidth}{|r|X|r|}
    \hline
    Nom & Description & Date \\
    \hline
    Stéphan Michaud & Création & 2013/02/04 \\
    \hline
    Équipe & Ébauche & 2013/02/26 \\
    \hline
    Jean-Philippe Caissy & Conversion en \LaTeX & 2013/03/04 \\
    \hline
    Jean-Philippe Caissy,& Fonctionalités & 2013/03/24\\
    Stéphan Michaud,& &\\
    Justin Michaud-Ouelette, & &\\
    Frédéric Sevillano & & \\
    \hline
    Maxime Bélanger & Règler quelques problèmes & 2013/03/27  \\
    \hline
    Guillaume Auger & Correction de l'orthographe & 2013/03/28  \\
     & Modification des acteurs &\\
     & Modifications aux définitions &\\
    \hline
\end{tabularx}

\chapter{Introduction}
Ce chapitre permet d'introduire la documentation du serveur Internet Nitcorn. Il permettra d'éliminer toute ambiguïté concernant la documentation
de notre application à l'aide de définitions, acronymes et
abréviations. Les objectifs et les portées seront décrits pour
avoir une meilleure compréhension du document.
\section{Objet}
L'objectif de ce document est de présenter une description complète et
détaillée des exigences de l'application Nitcorn. Le concept des exigences sera décrit textuellement et différents types de diagrammes seront utilisé pour illustrer l'interaction avec l'utilisateur. De plus, une spécification d'interface externe sera décrite permettant aux applications Nit existantes d'utiliser un serveur web.\\

Ce document s'adresse aux développeurs du projet Nitcorn ainsi qu'aux potentiels
contributeurs externes.
\section{Portée}
L'application dont le présent document décrit se nomme Nitcorn. Elle sera responsable d'offrir un serveur web aux applications Nit. Étant un nouveau language de programmation développé par un professeur de l'UQAM, Nit n'a pas encore de librairie capable d'établir une connexion entre une application et un serveur web. Le but de cette application est d'en offrir la possibilité. Le document sera composé d'une description des différentes composantes que le serveur va offrir à l'usager. Voici ces fonctionnalités:
\begin{itemize}
    \item Écoute sur un socket;
    \item Réception de requêtes HTTP 1.0 et 1.1;
    \item Traitement et réponse à une requête HTTP;
    \item Exposer une API pour gérer la configuration;
    \item Gestion de log;
    \item Transmettre les requêtes vers un serveur mandataire; et
    \item Permettre la ré-écriture des requêtes HTTP.
    \item Chiffrement et déchiffrement (SSL/TLS);
    \item Persistance de la configuration;
\end{itemize}

\section{Définitions, acronymes et abréviations}
Voici les définitions des différents termes techniques utilisés dans ce
document.
\begin{description}
    \item[Apache] Un serveur Web.
	\item[API]
	\item[Authentification Basic]
    \item[Authentification Digest]
	\item[Boucle d'événement asynchrone]
    \item[Contenu] Information binaire.
    \item[Cookie HTTP] Petit contenu envoyé par un site web et stocké par le client. Le contenu peut par la suite être récupéré par le serveur lors d'une prochaine visite.
    \item[Domaine] Fully qualified domain name. Nom qualifiant un et un seul emplacement dans les trois hiérarchies du DNS.
    \item[DNS] Domain Name System. Associe les domaines aux adresses IP.
    \item[Fastcgi] Protocole d'interface de programmes interactifs avec un serveur Web. 
    \item[Fil d'éxécution] Traitement d'une suite d'instructions par la machine sur un programme donné.
    \item[File descriptor] Identifiant d'un fichier ouvert par le système d'exploitation. 
 	\item[Header]
    \item[Host] Domaine.	
	\item[HTTP 1.0] Version 1.0 du protocole HTTP ne permettant pas d'avoir des
connexions keep-alive.
	\item[HTTP 1.1] Version 1.1 du protocole HTTP permettant entre autre d'avoir des****
    \item[Itanium] Processeurs 64 bits développés par Intel utilisant l'architecture IA_64 et non x86_64. Inclus ici les processeurs Itanium 2.
	\item[Log]   
    \item[Méthode HTTP] Intention de la requête.
	\item[MIME] Multipurpose Internet Mail Extensions. Est un identifiant de format de données composé de deux parties, utilisé par les serveurs pour distinguer le type de format.
	\item[Nit] Langage de programmation open source orienté objet développé par le
groupe de recherche sur l'étude, la spécification et l'implémentation des
langages informatique du département d'informatique à l'Université du Québec à
Montréal.
	\item[Nginx] Serveur asynchrone où chaque requête est traitée par un processus dédié.   
	\item[Protocole HTTP] Protocole de communication applicative d'architecture
client-serveur\cite{http}.
	\item[Requête HTTP] Demande envoyé par le client au serveur via un réseau.
Connexion keep-alive\cite{http1.0}.
	\item[Reverse Proxy] Type de serveur, habituellement placé en frontal de serveurs web. Il est à différencier dans son utilisation des serveurs proxys traditionnels.
    \item[Site web] Ensemble de pages web sur un même domaine.
	\item[Socket] Interface logiciel de connexion réseau.   
    \item[SSL] Secure Sockets Layer. Un protocole de sécurisation des échanges sur Internet.
	\item[Standard NCSA Common log format]  
    \item[TLS] Transport Layer Security. Un protocole de sécurisation des échanges sur Internet. 
    \item[UQAM] Université du Québec à Montréal.    
    \item[URI] Uniform resource identifier. Chaîne de caractères identifiant une ressource.
    \item[URL] Uniform resource locator. Adresse web qui réfère à une ressource.
    \item[Virtual Host] Ensemble d'hosts dont un serveur est responsable.
    \item[x86] Architecture de processeur 32 bits développée par Intel.
    \item[x86_64] Architecture de processeur 64 bits développée par AMD, mais compatible avec la famille de processeur 64 bits d'Intel (à l'exception de Itanium).

\end{description}

\section{Références}
\begin{tabularx}{\textwidth}{|l|X|l|}
    \hline
    Ref. & Numéro du document & Titre \\
    \hline
    \cite{ieefr} & IEEE 830-1993 & Norme IEEE 830-1993 \\
    \hline
    \cite{http} & RFC2616 & Hypertext Transfer Protocol -- HTTP/1.1 \\
    \hline
\end{tabularx}

\section{Vue d'ensemble}
Le  reste du document va contenir toutes les exigences de notre application organisées sous différentes sections.
\\
\\
La section 2 va contenir les facteurs généraux qui vont influencer le produit et ses exigences. Une description des différents modules du système sera présentée. Cette section traitera les aspects suivants:
\begin{description}
\item[Description] Description global du projet et de ses interfaces.
\item[Récit des fonctions] Récit décrivant une fonction du point de vue de son utilisateur. Organisé par utilisateurs.
\item[Caractéristiques des utilisateurs] Caractéristiques requises par les utilisateurs
\item[Contraintes] Éléments qui risquent de contraindre le développeur.
\item[Hypothèses et dépendances] Facteurs influençants les exigences.
\end{description}

La section 3 va couvrir en détail toutes les exigences du système afin que les concepteurs puissent être en mesure de concevoir le système et satisfaire les exigences du système. Cette section traitera les aspects suivants:

\begin{description}
\item[Exigences spécifiques] Décrit de façon précise les cas d'utilisation.
\item[Contraintes de conception] Contraintes qui doivent être suivi lors de la conception du système.
\item[Attributs] Attributs de logiciel pouvant servir d'exigences. 
\end{description}
\chapter{Description générale}
\section{Environnement}
Le but premier de Nitcorn est d'offrir aux applications développés en Nit la possibilité
d'utiliser un serveur web. On va donc devoir créer un module pour le langage Nit afin que d'autres applications Nit puissent être en mesure d'utiliser un serveur web. Il offrira des fonctionnalités de serveur au langage afin qu'il puisse être placé derrière un serveur web(Nginx, Apache,\ldots). Sous cette configuration, il va pouvoir répondre à des dizaines de milliers de requêtes web. Un service web sera utilisé afin de configurer le serveur. La gestion des logs ou la persistance des configuration devront être gérés automatiquement par le serveur web.\\ De cette façon, l'utilisateur pourrait avoir accès au log pour déterminer l'état du serveur. De plus, lorsqu'une erreur est détectée, un message d'erreur sera retourné à l'utilisateur. Nitcorn sera directement exposé à Internet et devra agir en tant qu'un serveur web exactement comme c'est le cas pour les autres
serveurs web (Nginx, Apache, \ldots). Sous cette configuration, les
fonctionnalités mentionnées ci-haut doivent être utilisées pour assurer les requis de traçabilité
et de fonctionnalités essentiels au serveur web.

\subsection{Interfaces avec le système}
Nitcorn sera utilisé sur deux systèmes : un serveur web et un environnement de développement.
Le serveur web sera le système ayant comme fonctionnalité d'agir en tant que serveur web, alors
que l'environnement de développement sera le système utilisé par les développeurs
pour développer des applications web en Nit.

\subsection{Interfaces avec les utilisateurs}
Comme il est disponible avec les autres serveurs web, un système de log est
disponible permettant à un utilisateur de déterminer la cause du problème. Sur
un autre point, le logiciel aura une API permettant aux applications Nit de
communiquer sur le web sans avoir à se soucier des configurations. Cette
API sera grandement inspirée par l'interface universelle WGSI développée pour
le langage Python. Le logiciel Nitcorn offrira aussi une interface pour les
applications Nit.

\subsection{Interfaces avec le matériel}
Nitcorn dépend du compilateur de Nit. Celui-ci est compatible pour le moment avec
les architectures x86 et x86_64.

\subsection{Interfaces avec les logiciels}
Nitcorn ne supporte que les systèmes d'exploitation de style UNIX (GNU/Linux, *BSD, Mac OS X, etc).
De plus, Nitcorn a besoin des logiciels suivants lors de la compilation : \\
\\
\begin{tabular}{|l|l|l|l|l|}
    \hline
    Nom & Mnémonique & Spécification & Version & Source \\
    \hline
    Nitc & N/A & FFI & N/A & \url{https://github.com/xymus/nit/tree/ffi} \\
    \hline
    Libevent & N/A & N/A & 2.0.X & \url{http://libevent.org/} \\
    \hline
    SQLite & N/A & N/A & 3.X & \url{https://www.sqlite.org/} \\
    \hline

\end{tabular}

\section{Fonctions}
Les différentes fonctions sont séparées en deux groupes : serveur et application Nit.
Le serveur est Nitcorn, alors que l'application Nit est l'application qui utilise
Nitcorn pour répondre à des requêtes web dynamiquement. De plus, une API est existante pour la gestion des configurations selon les préférences de l'utilisateur.\\

\subsection{Serveur}
\begin{itemize}
 \item Réception d'une requête
 \item Traiter une requête
 \item Lire la configuration
 \item Écrire la configuration
 \item Enregistrer les événements
\end{itemize}
\subsection{Application Nit}
\begin{itemize}
 \item Recevoir une requête HTTP
 \item Traiter une requête HTTP
\end{itemize}
\subsection{API}
\begin{itemize}
 \item Lire la configuration
 \item Modifier la configuration
 \item Enregistrer la configuration
\end{itemize}
\section{Caractéristiques des utilisateurs}
Les utilisateurs de Nitcorn seront en général soit des développeurs ou des
administrateurs de réseaux. Ce sont des gens qui ont soit une formation de
niveau collégiale ou universitaire ou une expérience professionnelle dans
le domaine du web. Il faudra connaître l'effet de certaines variables de
configuration ou être prêt à lire la documentation qui sera fournie.
Dernièrement, il y aura aussi les clients qui eux feront les requêtes
au serveur.
\section{Contraintes}

\subsection{Mémoire}
Nous n'imposons aucune contrainte mémoire. Par contre, la quantité de
\textbf{file descriptors} ouvert en même temps sera limitée par le noyau du
système d'exploitation. La limite est à la discrétion de l'utilisateur. Le
serveur devra gérer l'atteinte de cette limite.
\subsection{Exécution}
Le traitement des requêtes doit s'effectuer de façon asynchrone sur un seul fil
d'exécution. Plusieurs requêtes doivent être traitables simultanément sans bloquer
les nouvelles requêtes entrantes.
\subsection{Architecture}
Nous avons décidé d'utiliser un patron de conception basé sur
une boucle d’événements pour les communications bloquantes sur les sockets. Cela va 
permettre de n'utiliser qu'un seul processus pour le serveur, tout en restant très performant.
Ce mécanisme permet d'utiliser des mécanismes existant du système d'exploitation
pour gérer de manière asynchrone les entrées et sorties\cite{c10k}.
\subsection{Utilisation du serveur}
Le serveur devra supporter les méthodes HTTP suivantes:\\
\begin{itemize}
 \item TODO: En enlever?
 \item TODO: Ajouter des méthodes qui ne sont pas dans le RFC2616?
 \item OPTIONS
 \item GET
 \item HEAD
 \item POST
 \item PUT
 \item DELETE
 \item TRACE
 \item CONNECT
 \\
 
\end{itemize}

Le serveur devra être en mesure de supporter seulement les headers suivants: \\
\begin{itemize}

 \item TODO: Enlever ceux que l'on ne veux pas et inclut-on des headers non-standard?
 \item TODO: Ajouter les headers de reponses?
 \item TODO: \#\#\# : Ne sont pas dans le RFC 2616
 \item Accept
 \item Accept-Charset
 \item Accept-Encoding
 \item Accept-Language
 \item \#\#\#Accept-Datetime
 \item Accept-Ranges
 \item Age
 \item Allow
 \item Authorization
 \item Cache-Control
 \item Connection
 \item \#\#\#Cookie
 \item Content-Encoding
 \item Content-Language
 \item Content-Length
 \item Content-Location
 \item Content-MD5
 \item Content-Range
 \item Content-Type
 \item Date
 \item ETag
 \item Expect
 \item Expires
 \item From
 \item Host
 \item If-Match
 \item If-Modified-Since
 \item If-None-Match
 \item If-Range
 \item If-Unmodified-Since
 \item Last-Modified
 \item Location
 \item Max-Forwards
 \item \#\#\#Origin
 \item Pragma
 \item Proxy-Authentification
 \item Proxy-Authorization
 \item Range
 \item Referer
 \item Retry-After
 \item Server
 \item TE
 \item Trailer
 \item Transfert-Encoding
 \item Upgrade
 \item User-Agent
 \item Vary
 \item Via
 \item Warning
 \item WWW-Authenticate
 \\
 
\end{itemize}
 
 De plus, il sera en mesure de traiter les types d'erreurs suivants:\\
 \begin{itemize}
 \item TODO Voir quels autres ont supporte ou si on en enlève de ceux-ci.
 \item 200 - Ok
 \item 400 - Bad Request
 \item 401 - Unauthorized
 \item 403 - Forbidden
 \item 404 - Not Found
 \item 500 - Server Error
 \item 501 - Not implemented
 \item 502 - Bad Gateway
 \item 503 - Out of Resources
 \item 504 - Gateway Time-Out
 \item 505 - HTTP Version not supported

 \end{itemize}

 
    
\section{Hypothèse et dépendances}
Étant donné le sujet de l'application, il est essentiel d'avoir une connexion internet pour avoir accès au serveur web.\\



\chapter{Exigences spécifiques}

\section{Description des acteurs}
\subsection{Client:} Le client est le logiciel distant qui envoit les requêtes au serveur et qui en reçoit les réponses. 
\subsection{Administrateur:} L'adminisrateur est la personne qui s'occupe de la configuration et de la maintenant d'une des applications installées sur le serveur, par exemple un site web.
\subsection{Administrateur système:} L'administrateur système est la personne qui s'occupe de la configuration et de la maintenance du serveur et du système sur lequel est installé le serveur. C'est la personne possédant le plus de droits sur le serveur.
\subsection{Serveur:} C'est le logiciel décrit par le présent document, soit Nitcorn.




\section{Spécification des cas d'utilisation pour le serveur} 
À noter que nous utilisons la première personne du singulier pour représenter le serveur. De plus, chacune des fonctionnalités sont décrites sous forme de récit d'utilisateur.
\subsection{Réception d'une requête}
\subsubsection{Titre du cas d'utilisation:} Réception d'une requête
\subsubsection{Description sommaire:} Je reçois une requête et je l'envoie au module de traitement.
\subsubsection{Acteurs:}
\begin{itemize}
    \item Client
    \item Serveur
\end{itemize}
\subsubsection{Préconditions:}
\begin{itemize}
	\item Le client doit être connecté au serveur.
    \item Une requête doit avoir été envoyée par un client.
\end{itemize} 
\subsubsection{Postconditions:}
\begin{itemize}
    \item  L'information de la requête est envoyée au module de traitement.
    \item  Le log à été enregistré.
\end{itemize} 
\subsubsection{Description du processus:}
Je dois pouvoir recevoir une ou plusieurs requêtes simultanément. Après l'envoie d'une requête effectuée par le client, je vais écouter un ou plusieurs port(s) à l'aide d'un socket. Ensuite, je vais identifier le type de requête qui m'a été transmis et l'assigner au module de traitement sous forme de texte.


*** A Faire:DIAGRAMME
Example de requêtes;
Démontrer le traitement;
Example de retour ;
***

\subsection{Traiter une requête HTTP}
\subsubsection{Titre du cas d'utilisation:} Traiter une requête HTTP
\subsubsection{Description sommaire:} 
\subsubsection{Acteurs:}
\begin{itemize}
    \item Serveur
\end{itemize}
\subsubsection{Préconditions:}
\begin{itemize}
    \item  
\end{itemize} 
\subsubsection{Postconditions:}
\begin{itemize}
    \item  
\end{itemize} 
\subsubsection{Description du processus:}En tant que Nitcorn, je dois traiter une requête HTTP qui a été reçue. Une requête HTTP doit posséder les informations suivantes :
\begin{itemize}
    \item La version du protocole HTTP
    \item Le URI
    \item Le host
\end{itemize}
Avec les informations que j'ai, je vais pouvoir lire ma configuration actuelle. Si
je trouve un virtual host correspondant au host de ma requête, je vais utiliser la configuration de ce host. Sinon je vais utiliser la configuration du host par défaut. \\
\\
Le premier élément de la configuration que je lis pour ce host est de déterminer
si, pour ce host et URI, je dois soit : lire un fichier statique, passer la requête
à une application Nit, ou passer la requête à un serveur mandataire (reverse-proxy).\\
\\
Lorsque je traite une requête pour une page statique, je dois récupérer la page par
défaut et le dossier racine pour ce host. Avec ces informations-là, je peux renvoyer
le contenu de la page statique au requérant. Si je ne suis pas en mesure de lire
la page ou le dossier demandé, je dois retourner un message d'erreur au requérant
(404-Not Found, 401-Unauthorized, etc).\\
\\
Si la requête doit être passée à un serveur mandataire, je vais créer
une requête web avec les mêmes informations que la requête, mais je vais modifier
l'argument \textit{host} pour pointer vers le host du serveur mandataire. Lorsque
la requête est envoyée, je vais attendre la réception de la réponse et transmettre
cette réponse au client.
\\
Finalement, si la requête doit être transmise à une application Nit, je vais utiliser
le protocole (@TODO PROTOCOLE À DÉFINIR) pour communiquer avec l'application
qui m'a instanciée. Par la suite, je vais attendre de recevoir la réponse de l'application
et lorsque je l'ai reçu, je vais décoder cette réponse et créer la réponse HTTP
à transmettre avec les éléments suivants :
\begin{itemize}
    \item Le code de statut HTTP
    \item La taille de la réponse
    \item D'autres \textit{headers} transmis par l'application NIT
    \item Le contenu de la réponse
\end{itemize}
Après que la réponse est transmise au client, si le protocole HTTP est 1.0, je ferme
la connexion. Si le protocole HTTP est 1.1, je dois garder la connexion
ouverte. De plus, je vais écrire un événement pour cette réponse (voir section
\textit{Enregistrer les événements}).

\subsection{Lire la configuration}
\subsubsection{Titre du cas d'utilisation:} Lire la configuration
\subsubsection{Description sommaire:}
\subsubsection{Acteurs:}
\begin{itemize}
    \item Serveur
\end{itemize}
\subsubsection{Préconditions:}
\subsubsection{Postconditions:}
\subsubsection{Description du processus:}En tant que serveur, je vais faire une première lecture des mes configurations dans la base de données afin de connaître comment traiter les requêtes que je vais recevoir.
Pour éviter de faire une relecture dans la base de données pour chaque requête,
je vais écrire ces informations dans ma classe.
Si une application change ma configuration, je vais en tenir compte dans ma
classe pour éviter d'utiliser une configuration qui n'est plus à jour.

\subsection{Écrire la configuration}
\subsubsection{Titre du cas d'utilisation:} Écrire la configuration
\subsubsection{Description sommaire:}
\subsubsection{Acteurs:} 
\begin{itemize}
    \item Administrateur système ou administrateur
    \item Serveur
\end{itemize}
\subsubsection{Préconditions:}
\begin{itemize}
    \item  
\end{itemize} 
\subsubsection{Postconditions:}
\begin{itemize}
    \item  
\end{itemize} 
\subsubsection{Description du processus:}En tant que serveur, si un administrateur change la valeur de un ou plusieurs paramètre(s)
de configuration à l'aide de l'API en fournissant des nouvelles valeurs valides,
je dois ajuster mes attributs de classe et valeurs dans la base de donnée
pour tenir compte des ajustements.

\subsection{Enregistrer les événements}
\subsubsection{Titre du cas d'utilisation:} Enregistrer les événements
\subsubsection{Description sommaire:}
\subsubsection{Acteurs:}
\begin{itemize}
    \item Serveur
\end{itemize}
\subsubsection{Préconditions:}
\begin{itemize}
    \item  
\end{itemize} 
\subsubsection{Postconditions:}
\begin{itemize}
    \item  
\end{itemize} 
\subsubsection{Description du processus:}En tant que serveur, je désire garder un historique de mes transactions. Par
défaut je respecte le \textbf{standard NCSA Common log format}. Par contre je m'adapte
aux administrateurs, qui eux ont la possibilité de changer le format de
l'enregistrement. Mes enregistrements sont cours et concis. Ils expliquent
simplement qui a fait quoi et quand.

\section{Spécification des cas d'utilisation pour l'application Nit}
\subsection{Recevoir une requête HTTP}
\subsubsection{Titre du cas d'utilisation: Recevoir une requête HTTP}
\subsubsection{Description sommaire:}
\subsubsection{Acteurs:}
\begin{itemize}
	\item Client
    \item Serveur
\end{itemize}
\subsubsection{Préconditions:}
\begin{itemize}
    \item  
\end{itemize} 
\subsubsection{Postconditions:}
\begin{itemize}
    \item  
\end{itemize} 
\subsubsection{Description du processus:}En tant qu'application Nit, je peux recevoir une requête HTTP grâce à l'interface
(@TODO définir et nommer le protocole) me permettant de communiquer avec le serveur
Nitcorn. La réception d'une requête se fait en passant en paramètre les informations
reçu par Nitcorn (host, uri, headers).
\subsection{Traiter une requête HTTP}
\subsubsection{Titre du cas d'utilisation: Traiter une requête HTTP}
\subsubsection{Description sommaire:}
\subsubsection{Acteurs:}
\begin{itemize}
    \item Client
    \item Serveur
\end{itemize}
\subsubsection{Préconditions:}
\begin{itemize}
    \item  
\end{itemize} 
\subsubsection{Postconditions:}
\begin{itemize}
    \item  
\end{itemize} 
\subsubsection{Description du processus:}Après qu'une requête HTTP ai été reçue, je fait le traitement nécessaire.
Une fois ce traitement fait, je dois retourner (@TODO à voir avec spec de l'interface)
une réponse selon le protocole de l'interface avec Nitcorn. Cette réponse doit
contenir le contenu de la réponse HTTP, mais également le code de statut HTTP
et les différents \textit{headers} HTTP.

\section{Spécification des cas d'utilisation pour API}
\subsection{Lire la configuration}
\subsubsection{Titre du cas d'utilisation:} Lire la configuration
\subsubsection{Description sommaire:}
\subsubsection{Acteurs:}
\begin{itemize}
	\item Administrateur système ou administrateur
    \item Serveur
\end{itemize}
\subsubsection{Préconditions:}
\begin{itemize}
    \item  
\end{itemize} 
\subsubsection{Postconditions:}
\begin{itemize}
    \item  
\end{itemize} 
\subsubsection{Description du processus:}En tant qu'administrateur, si je veux savoir l'état de un ou plusieurs paramètres de
configuration sur le serveur, je vais utiliser une API pour interroger la
classe en question qui, elle, me retournera la ou les valeur(s) désirée(s).
Si j'utilise l'API pour interroger une classe à propos d'un paramètre
inexistant, je vais recevoir une erreur m'indiquant que la clé en question
n'existe pas.

\subsection{Enregistrer la configuration}
\subsubsection{Titre du cas d'utilisation:} Enregistrer la configuration
\subsubsection{Description sommaire:}
\subsubsection{Acteurs:}
\begin{itemize}
	\item Administrateur système ou administrateur
    \item Serveur
\end{itemize}
\subsubsection{Préconditions:}
\begin{itemize}
    \item  
\end{itemize} 
\subsubsection{Postconditions:}
\begin{itemize}
    \item  
\end{itemize} 
\subsubsection{Description du processus:}En tant qu'administrateur, si je désire apporter une modification à un ou plusieurs
paramètres de la configuration sur le serveur, je vais fournir la ou les nouvelle(s) valeur(s)
du ou des paramètre(s) désirée à l'API qui se chargera de relayer
l'information à la classe appropriée.
Si j'essaie de faire une modification sur un paramètre qui n'existe pas sur le
serveur à l'aide de l'API, je vais recevoir une erreur m'indiquant que la clé en
question n'existe pas.
Si j'essaie de faire une modification sur un paramètre à l'aide la l'API et que
je lui fournis une valeur qui est invalide dans le contexte du paramètre, je
vais recevoir une erreur m'indiquant que le paramètre ne peut pas contenir
la valeur fournie.

\section{Exigences des interfaces externes}
\subsection{Configuration}
Pour la configuration du serveur, un service web sera disponible pour configurer le serveur selon les préférences du client. (ACOMPLETE)
\section{Exigences fonctionnelles}
\section{Exigences de performance}
\section{Contraintes de conception}
\section{Attributs}
\subsection{Disponibilité}
\subsection{Sécurité}
\subsection{Maintenabilité}



\begin{thebibliography}{9}
\bibitem{ieefr}
  Société d'informatique IEEE,
\emph{Norme IEEE 830-1993, Pratique recommandée par IEEE pour la préparation de
spécifications d’exigences de logiciel}, 1993
\url{http://www.cours.polymtl.ca/log3410/bibliographie/IEEE/Pratique_Recommandee_Par_IEEE_pour_la%20_Specification.pdf}.
\bibitem{c10k}
  Dan Kegel
\emph{The C10K Problem}, 1999, \url{http://www.kegel.com/c10k.html#strategies}\bibitem{http}
    The Internet Society,
\emph{Hypertext Transfer Protocol -- HTTP/1.1}, 1999,
\url{https://tools.ietf.org/html/rfc2616}
\bibitem{http1.0}
    The Internet Society,
\emph{Hypertext Transfer Protocol -- HTTP/1.0}, 1996,
\url{https://tools.ietf.org/html/rfc1945}
\end{thebibliography}

% add other chapters and sections to suit
\end{document}
