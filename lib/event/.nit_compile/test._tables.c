/* This C file is generated by NIT to compile program test. */
#include "event._sep.h"
#include "standard._sep.h"
#include "standard___environ._sep.h"
#include "standard___string._sep.h"
#include "standard___collection._sep.h"
#include "standard___collection___range._sep.h"
#include "standard___collection___abstract_collection._sep.h"
#include "standard___kernel._sep.h"
#include "standard___collection___list._sep.h"
#include "standard___collection___sorter._sep.h"
#include "standard___collection___array._sep.h"
#include "standard___collection___hash_collection._sep.h"
#include "standard___hash._sep.h"
#include "standard___time._sep.h"
#include "standard___file._sep.h"
#include "standard___stream._sep.h"
#include "standard___string_search._sep.h"
#include "standard___exec._sep.h"
#include "standard___math._sep.h"
#include "standard___gc._sep.h"
#include "test._sep.h"
#include <nit_common.h>
void INIT_ATTRIBUTES__standard___kernel___Sys(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___kernel___Sys_t)(val_t p0);
val_t NEW_standard___kernel___Sys(void);
void CHECKNEW_standard___kernel___Sys(val_t p0);
typedef void (*CHECKNEW_standard___kernel___Sys_t)(val_t p0);
val_t NEW_Sys_standard___kernel___Sys___init(void);
typedef val_t (*NEW_Sys_standard___kernel___Sys___init_t)(void);
void INIT_ATTRIBUTES__standard___collection___abstract_collection___Container(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___abstract_collection___Container_t)(val_t p0);
val_t NEW_standard___collection___abstract_collection___Container(void);
void CHECKNEW_standard___collection___abstract_collection___Container(val_t p0);
typedef void (*CHECKNEW_standard___collection___abstract_collection___Container_t)(val_t p0);
val_t NEW_Container_standard___collection___abstract_collection___Container___init(val_t p0);
typedef val_t (*NEW_Container_standard___collection___abstract_collection___Container___init_t)(val_t p0);
void INIT_ATTRIBUTES__standard___collection___abstract_collection___ContainerIterator(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___abstract_collection___ContainerIterator_t)(val_t p0);
val_t NEW_standard___collection___abstract_collection___ContainerIterator(void);
void CHECKNEW_standard___collection___abstract_collection___ContainerIterator(val_t p0);
typedef void (*CHECKNEW_standard___collection___abstract_collection___ContainerIterator_t)(val_t p0);
val_t NEW_ContainerIterator_standard___collection___abstract_collection___ContainerIterator___init(val_t p0);
typedef val_t (*NEW_ContainerIterator_standard___collection___abstract_collection___ContainerIterator___init_t)(val_t p0);
void INIT_ATTRIBUTES__standard___collection___abstract_collection___MapKeysIterator(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___abstract_collection___MapKeysIterator_t)(val_t p0);
val_t NEW_standard___collection___abstract_collection___MapKeysIterator(void);
void CHECKNEW_standard___collection___abstract_collection___MapKeysIterator(val_t p0);
typedef void (*CHECKNEW_standard___collection___abstract_collection___MapKeysIterator_t)(val_t p0);
val_t NEW_MapKeysIterator_standard___collection___abstract_collection___MapKeysIterator___init(val_t p0);
typedef val_t (*NEW_MapKeysIterator_standard___collection___abstract_collection___MapKeysIterator___init_t)(val_t p0);
void INIT_ATTRIBUTES__standard___collection___abstract_collection___MapValuesIterator(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___abstract_collection___MapValuesIterator_t)(val_t p0);
val_t NEW_standard___collection___abstract_collection___MapValuesIterator(void);
void CHECKNEW_standard___collection___abstract_collection___MapValuesIterator(val_t p0);
typedef void (*CHECKNEW_standard___collection___abstract_collection___MapValuesIterator_t)(val_t p0);
val_t NEW_MapValuesIterator_standard___collection___abstract_collection___MapValuesIterator___init(val_t p0);
typedef val_t (*NEW_MapValuesIterator_standard___collection___abstract_collection___MapValuesIterator___init_t)(val_t p0);
void INIT_ATTRIBUTES__standard___collection___abstract_collection___CoupleMapIterator(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___abstract_collection___CoupleMapIterator_t)(val_t p0);
val_t NEW_standard___collection___abstract_collection___CoupleMapIterator(void);
void CHECKNEW_standard___collection___abstract_collection___CoupleMapIterator(val_t p0);
typedef void (*CHECKNEW_standard___collection___abstract_collection___CoupleMapIterator_t)(val_t p0);
val_t NEW_CoupleMapIterator_standard___collection___abstract_collection___CoupleMapIterator___init(val_t p0);
typedef val_t (*NEW_CoupleMapIterator_standard___collection___abstract_collection___CoupleMapIterator___init_t)(val_t p0);
void INIT_ATTRIBUTES__standard___collection___abstract_collection___Couple(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___abstract_collection___Couple_t)(val_t p0);
val_t NEW_standard___collection___abstract_collection___Couple(void);
void CHECKNEW_standard___collection___abstract_collection___Couple(val_t p0);
typedef void (*CHECKNEW_standard___collection___abstract_collection___Couple_t)(val_t p0);
val_t NEW_Couple_standard___collection___abstract_collection___Couple___init(val_t p0, val_t p1);
typedef val_t (*NEW_Couple_standard___collection___abstract_collection___Couple___init_t)(val_t p0, val_t p1);
void INIT_ATTRIBUTES__standard___collection___range___Range(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___range___Range_t)(val_t p0);
val_t NEW_standard___collection___range___Range(void);
void CHECKNEW_standard___collection___range___Range(val_t p0);
typedef void (*CHECKNEW_standard___collection___range___Range_t)(val_t p0);
val_t NEW_Range_standard___collection___range___Range___init(val_t p0, val_t p1);
typedef val_t (*NEW_Range_standard___collection___range___Range___init_t)(val_t p0, val_t p1);
val_t NEW_Range_standard___collection___range___Range___without_last(val_t p0, val_t p1);
typedef val_t (*NEW_Range_standard___collection___range___Range___without_last_t)(val_t p0, val_t p1);
void INIT_ATTRIBUTES__standard___collection___range___IteratorRange(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___range___IteratorRange_t)(val_t p0);
val_t NEW_standard___collection___range___IteratorRange(void);
void CHECKNEW_standard___collection___range___IteratorRange(val_t p0);
typedef void (*CHECKNEW_standard___collection___range___IteratorRange_t)(val_t p0);
val_t NEW_IteratorRange_standard___collection___range___IteratorRange___init(val_t p0);
typedef val_t (*NEW_IteratorRange_standard___collection___range___IteratorRange___init_t)(val_t p0);
void INIT_ATTRIBUTES__standard___collection___list___List(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___list___List_t)(val_t p0);
val_t NEW_standard___collection___list___List(void);
void CHECKNEW_standard___collection___list___List(val_t p0);
typedef void (*CHECKNEW_standard___collection___list___List_t)(val_t p0);
val_t NEW_List_standard___collection___list___List___init(void);
typedef val_t (*NEW_List_standard___collection___list___List___init_t)(void);
val_t NEW_List_standard___collection___list___List___from(val_t p0);
typedef val_t (*NEW_List_standard___collection___list___List___from_t)(val_t p0);
void INIT_ATTRIBUTES__standard___collection___list___ListIterator(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___list___ListIterator_t)(val_t p0);
val_t NEW_standard___collection___list___ListIterator(void);
void CHECKNEW_standard___collection___list___ListIterator(val_t p0);
typedef void (*CHECKNEW_standard___collection___list___ListIterator_t)(val_t p0);
val_t NEW_ListIterator_standard___collection___list___ListIterator___init(val_t p0);
typedef val_t (*NEW_ListIterator_standard___collection___list___ListIterator___init_t)(val_t p0);
void INIT_ATTRIBUTES__standard___collection___list___ListNode(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___list___ListNode_t)(val_t p0);
val_t NEW_standard___collection___list___ListNode(void);
void CHECKNEW_standard___collection___list___ListNode(val_t p0);
typedef void (*CHECKNEW_standard___collection___list___ListNode_t)(val_t p0);
val_t NEW_ListNode_standard___collection___list___ListNode___init(val_t p0);
typedef val_t (*NEW_ListNode_standard___collection___list___ListNode___init_t)(val_t p0);
void INIT_ATTRIBUTES__standard___collection___array___Array(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___array___Array_t)(val_t p0);
val_t NEW_standard___collection___array___Array(void);
void CHECKNEW_standard___collection___array___Array(val_t p0);
typedef void (*CHECKNEW_standard___collection___array___Array_t)(val_t p0);
val_t NEW_Array_standard___collection___array___Array___with_capacity(val_t p0);
typedef val_t (*NEW_Array_standard___collection___array___Array___with_capacity_t)(val_t p0);
val_t NEW_Array_standard___collection___array___Array___init(void);
typedef val_t (*NEW_Array_standard___collection___array___Array___init_t)(void);
val_t NEW_Array_standard___collection___array___Array___filled_with(val_t p0, val_t p1);
typedef val_t (*NEW_Array_standard___collection___array___Array___filled_with_t)(val_t p0, val_t p1);
val_t NEW_Array_standard___collection___array___Array___with_items(val_t p0);
typedef val_t (*NEW_Array_standard___collection___array___Array___with_items_t)(val_t p0);
val_t NEW_Array_standard___collection___array___Array___with_native(val_t p0, val_t p1);
typedef val_t (*NEW_Array_standard___collection___array___Array___with_native_t)(val_t p0, val_t p1);
void INIT_ATTRIBUTES__standard___collection___array___ArrayIterator(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___array___ArrayIterator_t)(val_t p0);
val_t NEW_standard___collection___array___ArrayIterator(void);
void CHECKNEW_standard___collection___array___ArrayIterator(val_t p0);
typedef void (*CHECKNEW_standard___collection___array___ArrayIterator_t)(val_t p0);
val_t NEW_ArrayIterator_standard___collection___array___ArrayIterator___init(val_t p0);
typedef val_t (*NEW_ArrayIterator_standard___collection___array___ArrayIterator___init_t)(val_t p0);
void INIT_ATTRIBUTES__standard___collection___array___ArraySet(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___array___ArraySet_t)(val_t p0);
val_t NEW_standard___collection___array___ArraySet(void);
void CHECKNEW_standard___collection___array___ArraySet(val_t p0);
typedef void (*CHECKNEW_standard___collection___array___ArraySet_t)(val_t p0);
val_t NEW_ArraySet_standard___collection___array___ArraySet___init(void);
typedef val_t (*NEW_ArraySet_standard___collection___array___ArraySet___init_t)(void);
val_t NEW_ArraySet_standard___collection___array___ArraySet___with_capacity(val_t p0);
typedef val_t (*NEW_ArraySet_standard___collection___array___ArraySet___with_capacity_t)(val_t p0);
void INIT_ATTRIBUTES__standard___collection___array___ArraySetIterator(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___array___ArraySetIterator_t)(val_t p0);
val_t NEW_standard___collection___array___ArraySetIterator(void);
void CHECKNEW_standard___collection___array___ArraySetIterator(val_t p0);
typedef void (*CHECKNEW_standard___collection___array___ArraySetIterator_t)(val_t p0);
val_t NEW_ArraySetIterator_standard___collection___array___ArraySetIterator___init(val_t p0);
typedef val_t (*NEW_ArraySetIterator_standard___collection___array___ArraySetIterator___init_t)(val_t p0);
void INIT_ATTRIBUTES__standard___collection___array___ArrayMap(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___array___ArrayMap_t)(val_t p0);
val_t NEW_standard___collection___array___ArrayMap(void);
void CHECKNEW_standard___collection___array___ArrayMap(val_t p0);
typedef void (*CHECKNEW_standard___collection___array___ArrayMap_t)(val_t p0);
val_t NEW_ArrayMap_standard___collection___array___ArrayMap___init(void);
typedef val_t (*NEW_ArrayMap_standard___collection___array___ArrayMap___init_t)(void);
void INIT_ATTRIBUTES__standard___collection___array___ArrayMapKeys(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___array___ArrayMapKeys_t)(val_t p0);
val_t NEW_standard___collection___array___ArrayMapKeys(void);
void CHECKNEW_standard___collection___array___ArrayMapKeys(val_t p0);
typedef void (*CHECKNEW_standard___collection___array___ArrayMapKeys_t)(val_t p0);
val_t NEW_ArrayMapKeys_standard___collection___array___ArrayMapKeys___init(val_t p0);
typedef val_t (*NEW_ArrayMapKeys_standard___collection___array___ArrayMapKeys___init_t)(val_t p0);
void INIT_ATTRIBUTES__standard___collection___array___ArrayMapValues(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___array___ArrayMapValues_t)(val_t p0);
val_t NEW_standard___collection___array___ArrayMapValues(void);
void CHECKNEW_standard___collection___array___ArrayMapValues(val_t p0);
typedef void (*CHECKNEW_standard___collection___array___ArrayMapValues_t)(val_t p0);
val_t NEW_ArrayMapValues_standard___collection___array___ArrayMapValues___init(val_t p0);
typedef val_t (*NEW_ArrayMapValues_standard___collection___array___ArrayMapValues___init_t)(val_t p0);
void INIT_ATTRIBUTES__standard___collection___sorter___ComparableSorter(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___sorter___ComparableSorter_t)(val_t p0);
val_t NEW_standard___collection___sorter___ComparableSorter(void);
void CHECKNEW_standard___collection___sorter___ComparableSorter(val_t p0);
typedef void (*CHECKNEW_standard___collection___sorter___ComparableSorter_t)(val_t p0);
val_t NEW_ComparableSorter_standard___collection___sorter___ComparableSorter___init(void);
typedef val_t (*NEW_ComparableSorter_standard___collection___sorter___ComparableSorter___init_t)(void);
void INIT_ATTRIBUTES__standard___collection___hash_collection___HashMap(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___hash_collection___HashMap_t)(val_t p0);
val_t NEW_standard___collection___hash_collection___HashMap(void);
void CHECKNEW_standard___collection___hash_collection___HashMap(val_t p0);
typedef void (*CHECKNEW_standard___collection___hash_collection___HashMap_t)(val_t p0);
val_t NEW_HashMap_standard___collection___hash_collection___HashMap___init(void);
typedef val_t (*NEW_HashMap_standard___collection___hash_collection___HashMap___init_t)(void);
void INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapKeys(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapKeys_t)(val_t p0);
val_t NEW_standard___collection___hash_collection___HashMapKeys(void);
void CHECKNEW_standard___collection___hash_collection___HashMapKeys(val_t p0);
typedef void (*CHECKNEW_standard___collection___hash_collection___HashMapKeys_t)(val_t p0);
val_t NEW_HashMapKeys_standard___collection___hash_collection___HashMapKeys___init(val_t p0);
typedef val_t (*NEW_HashMapKeys_standard___collection___hash_collection___HashMapKeys___init_t)(val_t p0);
void INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapValues(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapValues_t)(val_t p0);
val_t NEW_standard___collection___hash_collection___HashMapValues(void);
void CHECKNEW_standard___collection___hash_collection___HashMapValues(val_t p0);
typedef void (*CHECKNEW_standard___collection___hash_collection___HashMapValues_t)(val_t p0);
val_t NEW_HashMapValues_standard___collection___hash_collection___HashMapValues___init(val_t p0);
typedef val_t (*NEW_HashMapValues_standard___collection___hash_collection___HashMapValues___init_t)(val_t p0);
void INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapNode(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapNode_t)(val_t p0);
val_t NEW_standard___collection___hash_collection___HashMapNode(void);
void CHECKNEW_standard___collection___hash_collection___HashMapNode(val_t p0);
typedef void (*CHECKNEW_standard___collection___hash_collection___HashMapNode_t)(val_t p0);
val_t NEW_HashMapNode_standard___collection___hash_collection___HashMapNode___init(val_t p0, val_t p1);
typedef val_t (*NEW_HashMapNode_standard___collection___hash_collection___HashMapNode___init_t)(val_t p0, val_t p1);
void INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapIterator(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapIterator_t)(val_t p0);
val_t NEW_standard___collection___hash_collection___HashMapIterator(void);
void CHECKNEW_standard___collection___hash_collection___HashMapIterator(val_t p0);
typedef void (*CHECKNEW_standard___collection___hash_collection___HashMapIterator_t)(val_t p0);
val_t NEW_HashMapIterator_standard___collection___hash_collection___HashMapIterator___init(val_t p0);
typedef val_t (*NEW_HashMapIterator_standard___collection___hash_collection___HashMapIterator___init_t)(val_t p0);
void INIT_ATTRIBUTES__standard___collection___hash_collection___HashSet(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___hash_collection___HashSet_t)(val_t p0);
val_t NEW_standard___collection___hash_collection___HashSet(void);
void CHECKNEW_standard___collection___hash_collection___HashSet(val_t p0);
typedef void (*CHECKNEW_standard___collection___hash_collection___HashSet_t)(val_t p0);
val_t NEW_HashSet_standard___collection___hash_collection___HashSet___init(void);
typedef val_t (*NEW_HashSet_standard___collection___hash_collection___HashSet___init_t)(void);
void INIT_ATTRIBUTES__standard___collection___hash_collection___HashSetNode(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___hash_collection___HashSetNode_t)(val_t p0);
val_t NEW_standard___collection___hash_collection___HashSetNode(void);
void CHECKNEW_standard___collection___hash_collection___HashSetNode(val_t p0);
typedef void (*CHECKNEW_standard___collection___hash_collection___HashSetNode_t)(val_t p0);
val_t NEW_HashSetNode_standard___collection___hash_collection___HashSetNode___init(val_t p0);
typedef val_t (*NEW_HashSetNode_standard___collection___hash_collection___HashSetNode___init_t)(val_t p0);
void INIT_ATTRIBUTES__standard___collection___hash_collection___HashSetIterator(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___collection___hash_collection___HashSetIterator_t)(val_t p0);
val_t NEW_standard___collection___hash_collection___HashSetIterator(void);
void CHECKNEW_standard___collection___hash_collection___HashSetIterator(val_t p0);
typedef void (*CHECKNEW_standard___collection___hash_collection___HashSetIterator_t)(val_t p0);
val_t NEW_HashSetIterator_standard___collection___hash_collection___HashSetIterator___init(val_t p0);
typedef val_t (*NEW_HashSetIterator_standard___collection___hash_collection___HashSetIterator___init_t)(val_t p0);
void INIT_ATTRIBUTES__standard___string___String(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___string___String_t)(val_t p0);
val_t NEW_standard___string___String(void);
void CHECKNEW_standard___string___String(val_t p0);
typedef void (*CHECKNEW_standard___string___String_t)(val_t p0);
val_t NEW_String_standard___string___String___with_native(val_t p0, val_t p1);
typedef val_t (*NEW_String_standard___string___String___with_native_t)(val_t p0, val_t p1);
val_t NEW_String_standard___string___String___from_cstring(val_t p0);
typedef val_t (*NEW_String_standard___string___String___from_cstring_t)(val_t p0);
void INIT_ATTRIBUTES__standard___string___Buffer(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___string___Buffer_t)(val_t p0);
val_t NEW_standard___string___Buffer(void);
void CHECKNEW_standard___string___Buffer(val_t p0);
typedef void (*CHECKNEW_standard___string___Buffer_t)(val_t p0);
val_t NEW_Buffer_standard___string___Buffer___init(void);
typedef val_t (*NEW_Buffer_standard___string___Buffer___init_t)(void);
val_t NEW_Buffer_standard___string___Buffer___from(val_t p0);
typedef val_t (*NEW_Buffer_standard___string___Buffer___from_t)(val_t p0);
val_t NEW_Buffer_standard___string___Buffer___with_capacity(val_t p0);
typedef val_t (*NEW_Buffer_standard___string___Buffer___with_capacity_t)(val_t p0);
void INIT_ATTRIBUTES__standard___stream___FDIStream(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___stream___FDIStream_t)(val_t p0);
val_t NEW_standard___stream___FDIStream(void);
void CHECKNEW_standard___stream___FDIStream(val_t p0);
typedef void (*CHECKNEW_standard___stream___FDIStream_t)(val_t p0);
val_t NEW_FDIStream_standard___stream___FDIStream___init(val_t p0);
typedef val_t (*NEW_FDIStream_standard___stream___FDIStream___init_t)(val_t p0);
void INIT_ATTRIBUTES__standard___stream___FDOStream(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___stream___FDOStream_t)(val_t p0);
val_t NEW_standard___stream___FDOStream(void);
void CHECKNEW_standard___stream___FDOStream(val_t p0);
typedef void (*CHECKNEW_standard___stream___FDOStream_t)(val_t p0);
val_t NEW_FDOStream_standard___stream___FDOStream___init(val_t p0);
typedef val_t (*NEW_FDOStream_standard___stream___FDOStream___init_t)(val_t p0);
void INIT_ATTRIBUTES__standard___stream___FDIOStream(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___stream___FDIOStream_t)(val_t p0);
val_t NEW_standard___stream___FDIOStream(void);
void CHECKNEW_standard___stream___FDIOStream(val_t p0);
typedef void (*CHECKNEW_standard___stream___FDIOStream_t)(val_t p0);
val_t NEW_FDIOStream_standard___stream___FDIOStream___init(val_t p0);
typedef val_t (*NEW_FDIOStream_standard___stream___FDIOStream___init_t)(val_t p0);
void INIT_ATTRIBUTES__standard___string_search___BM_Pattern(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___string_search___BM_Pattern_t)(val_t p0);
val_t NEW_standard___string_search___BM_Pattern(void);
void CHECKNEW_standard___string_search___BM_Pattern(val_t p0);
typedef void (*CHECKNEW_standard___string_search___BM_Pattern_t)(val_t p0);
val_t NEW_BM_Pattern_standard___string_search___BM_Pattern___init(val_t p0);
typedef val_t (*NEW_BM_Pattern_standard___string_search___BM_Pattern___init_t)(val_t p0);
void INIT_ATTRIBUTES__standard___string_search___Match(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___string_search___Match_t)(val_t p0);
val_t NEW_standard___string_search___Match(void);
void CHECKNEW_standard___string_search___Match(val_t p0);
typedef void (*CHECKNEW_standard___string_search___Match_t)(val_t p0);
val_t NEW_Match_standard___string_search___Match___init(val_t p0, val_t p1, val_t p2);
typedef val_t (*NEW_Match_standard___string_search___Match___init_t)(val_t p0, val_t p1, val_t p2);
void INIT_ATTRIBUTES__standard___file___IFStream(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___file___IFStream_t)(val_t p0);
val_t NEW_standard___file___IFStream(void);
void CHECKNEW_standard___file___IFStream(val_t p0);
typedef void (*CHECKNEW_standard___file___IFStream_t)(val_t p0);
val_t NEW_IFStream_standard___file___IFStream___open(val_t p0);
typedef val_t (*NEW_IFStream_standard___file___IFStream___open_t)(val_t p0);
val_t NEW_IFStream_standard___file___IFStream___init(void);
typedef val_t (*NEW_IFStream_standard___file___IFStream___init_t)(void);
val_t NEW_IFStream_standard___file___IFStream___without_file(void);
typedef val_t (*NEW_IFStream_standard___file___IFStream___without_file_t)(void);
void INIT_ATTRIBUTES__standard___file___OFStream(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___file___OFStream_t)(val_t p0);
val_t NEW_standard___file___OFStream(void);
void CHECKNEW_standard___file___OFStream(val_t p0);
typedef void (*CHECKNEW_standard___file___OFStream_t)(val_t p0);
val_t NEW_OFStream_standard___file___OFStream___open(val_t p0);
typedef val_t (*NEW_OFStream_standard___file___OFStream___open_t)(val_t p0);
val_t NEW_OFStream_standard___file___OFStream___init(void);
typedef val_t (*NEW_OFStream_standard___file___OFStream___init_t)(void);
val_t NEW_OFStream_standard___file___OFStream___without_file(void);
typedef val_t (*NEW_OFStream_standard___file___OFStream___without_file_t)(void);
void INIT_ATTRIBUTES__standard___file___Stdin(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___file___Stdin_t)(val_t p0);
val_t NEW_standard___file___Stdin(void);
void CHECKNEW_standard___file___Stdin(val_t p0);
typedef void (*CHECKNEW_standard___file___Stdin_t)(val_t p0);
val_t NEW_Stdin_standard___file___Stdin___init(void);
typedef val_t (*NEW_Stdin_standard___file___Stdin___init_t)(void);
void INIT_ATTRIBUTES__standard___file___Stdout(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___file___Stdout_t)(val_t p0);
val_t NEW_standard___file___Stdout(void);
void CHECKNEW_standard___file___Stdout(val_t p0);
typedef void (*CHECKNEW_standard___file___Stdout_t)(val_t p0);
val_t NEW_Stdout_standard___file___Stdout___init(void);
typedef val_t (*NEW_Stdout_standard___file___Stdout___init_t)(void);
void INIT_ATTRIBUTES__standard___file___Stderr(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___file___Stderr_t)(val_t p0);
val_t NEW_standard___file___Stderr(void);
void CHECKNEW_standard___file___Stderr(val_t p0);
typedef void (*CHECKNEW_standard___file___Stderr_t)(val_t p0);
val_t NEW_Stderr_standard___file___Stderr___init(void);
typedef val_t (*NEW_Stderr_standard___file___Stderr___init_t)(void);
void INIT_ATTRIBUTES__standard___exec___Process(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___exec___Process_t)(val_t p0);
val_t NEW_standard___exec___Process(void);
void CHECKNEW_standard___exec___Process(val_t p0);
typedef void (*CHECKNEW_standard___exec___Process_t)(val_t p0);
val_t NEW_Process_standard___exec___Process___init(val_t p0, val_t p1);
typedef val_t (*NEW_Process_standard___exec___Process___init_t)(val_t p0, val_t p1);
val_t NEW_Process_standard___exec___Process___init_(val_t p0);
typedef val_t (*NEW_Process_standard___exec___Process___init__t)(val_t p0);
val_t NEW_Process_standard___exec___Process___execute(val_t p0, val_t p1, val_t p2);
typedef val_t (*NEW_Process_standard___exec___Process___execute_t)(val_t p0, val_t p1, val_t p2);
void INIT_ATTRIBUTES__standard___exec___IProcess(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___exec___IProcess_t)(val_t p0);
val_t NEW_standard___exec___IProcess(void);
void CHECKNEW_standard___exec___IProcess(val_t p0);
typedef void (*CHECKNEW_standard___exec___IProcess_t)(val_t p0);
val_t NEW_IProcess_standard___exec___IProcess___init(val_t p0, val_t p1);
typedef val_t (*NEW_IProcess_standard___exec___IProcess___init_t)(val_t p0, val_t p1);
val_t NEW_IProcess_standard___exec___IProcess___init_(val_t p0);
typedef val_t (*NEW_IProcess_standard___exec___IProcess___init__t)(val_t p0);
void INIT_ATTRIBUTES__standard___exec___OProcess(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___exec___OProcess_t)(val_t p0);
val_t NEW_standard___exec___OProcess(void);
void CHECKNEW_standard___exec___OProcess(val_t p0);
typedef void (*CHECKNEW_standard___exec___OProcess_t)(val_t p0);
val_t NEW_OProcess_standard___exec___OProcess___init(val_t p0, val_t p1);
typedef val_t (*NEW_OProcess_standard___exec___OProcess___init_t)(val_t p0, val_t p1);
val_t NEW_OProcess_standard___exec___OProcess___init_(val_t p0);
typedef val_t (*NEW_OProcess_standard___exec___OProcess___init__t)(val_t p0);
void INIT_ATTRIBUTES__standard___exec___IOProcess(val_t p0);
typedef void (*INIT_ATTRIBUTES__standard___exec___IOProcess_t)(val_t p0);
val_t NEW_standard___exec___IOProcess(void);
void CHECKNEW_standard___exec___IOProcess(val_t p0);
typedef void (*CHECKNEW_standard___exec___IOProcess_t)(val_t p0);
val_t NEW_IOProcess_standard___exec___IOProcess___init(val_t p0, val_t p1);
typedef val_t (*NEW_IOProcess_standard___exec___IOProcess___init_t)(val_t p0, val_t p1);
val_t NEW_IOProcess_standard___exec___IOProcess___init_(val_t p0);
typedef val_t (*NEW_IOProcess_standard___exec___IOProcess___init__t)(val_t p0);
const char LOCATE_event[] = "event.nit";
const int SFT_event[9] = {
  -29 /* Id of EventBase */,
  5 /* Color of EventBase */,
  47 /* Group of ? */,
  63 /* Id of Callback */,
  5 /* Color of Callback */,
  47 /* Group of ? */,
  -33 /* Id of ConnectionListener */,
  6 /* Color of ConnectionListener */,
  50 /* Group of ? */,
};
const char LOCATE_standard[] = "/home/jp/Projects-ssd/nit/lib/standard/standard.nit";
const char LOCATE_standard___environ[] = "/home/jp/Projects-ssd/nit/lib/standard/environ.nit";
const int SFT_standard___environ[2] = {
  111 /* Group of ? */,
  46 /* Group of ? */,
};
const char LOCATE_standard___string[] = "/home/jp/Projects-ssd/nit/lib/standard/string.nit";
const int SFT_standard___string[24] = {
  279 /* Id of AbstractString */,
  12 /* Color of AbstractString */,
  3 /* Group of ? */,
  99 /* Group of ? */,
  283 /* Id of String */,
  8 /* Color of String */,
  112 /* Group of ? */,
  307 /* Id of Buffer */,
  14 /* Color of Buffer */,
  4 /* Group of ? */,
  115 /* Group of ? */,
  35 /* Group of ? */,
  68 /* Group of ? */,
  46 /* Group of ? */,
  62 /* Group of ? */,
  57 /* Group of ? */,
  -5 /* Id of NativeString */,
  4 /* Color of NativeString */,
  47 /* Group of ? */,
  11 /* Id of StringCapable */,
  4 /* Color of StringCapable */,
  46 /* Group of ? */,
  2 /* Group of ? */,
  47 /* Group of ? */,
};
const char LOCATE_standard___collection[] = "/home/jp/Projects-ssd/nit/lib/standard/collection/collection.nit";
const char LOCATE_standard___collection___range[] = "/home/jp/Projects-ssd/nit/lib/standard/collection/range.nit";
const int SFT_standard___collection___range[8] = {
  83 /* Id of Range */,
  7 /* Color of Range */,
  2 /* Group of ? */,
  74 /* Group of ? */,
  107 /* Id of IteratorRange */,
  5 /* Color of IteratorRange */,
  2 /* Group of ? */,
  51 /* Group of ? */,
};
const char LOCATE_standard___collection___abstract_collection[] = "/home/jp/Projects-ssd/nit/lib/standard/collection/abstract_collection.nit";
const int SFT_standard___collection___abstract_collection[63] = {
  59 /* Id of Collection */,
  6 /* Color of Collection */,
  64 /* Group of ? */,
  91 /* Id of NaiveCollection */,
  7 /* Color of NaiveCollection */,
  74 /* Group of ? */,
  39 /* Id of Iterator */,
  4 /* Color of Iterator */,
  47 /* Group of ? */,
  159 /* Id of Container */,
  7 /* Color of Container */,
  2 /* Group of ? */,
  74 /* Group of ? */,
  155 /* Id of ContainerIterator */,
  5 /* Color of ContainerIterator */,
  2 /* Group of ? */,
  51 /* Group of ? */,
  79 /* Id of RemovableCollection */,
  8 /* Color of RemovableCollection */,
  78 /* Group of ? */,
  175 /* Id of SimpleCollection */,
  9 /* Color of SimpleCollection */,
  48 /* Group of ? */,
  255 /* Id of Set */,
  4 /* Color of Set */,
  46 /* Group of ? */,
  31 /* Id of MapRead */,
  4 /* Color of MapRead */,
  46 /* Group of ? */,
  103 /* Id of Map */,
  6 /* Color of Map */,
  58 /* Group of ? */,
  35 /* Id of MapIterator */,
  4 /* Color of MapIterator */,
  46 /* Group of ? */,
  99 /* Id of MapKeysIterator */,
  5 /* Color of MapKeysIterator */,
  2 /* Group of ? */,
  51 /* Group of ? */,
  95 /* Id of MapValuesIterator */,
  5 /* Color of MapValuesIterator */,
  2 /* Group of ? */,
  51 /* Group of ? */,
  75 /* Id of SequenceRead */,
  7 /* Color of SequenceRead */,
  74 /* Group of ? */,
  259 /* Id of Sequence */,
  11 /* Color of Sequence */,
  89 /* Group of ? */,
  111 /* Id of IndexedIterator */,
  5 /* Color of IndexedIterator */,
  51 /* Group of ? */,
  223 /* Id of CoupleMap */,
  7 /* Color of CoupleMap */,
  62 /* Group of ? */,
  151 /* Id of CoupleMapIterator */,
  5 /* Color of CoupleMapIterator */,
  2 /* Group of ? */,
  51 /* Group of ? */,
  51 /* Id of Couple */,
  4 /* Color of Couple */,
  2 /* Group of ? */,
  46 /* Group of ? */,
};
const char LOCATE_standard___kernel[] = "/home/jp/Projects-ssd/nit/lib/standard/kernel.nit";
const int SFT_standard___kernel[27] = {
  3 /* Id of Object */,
  3 /* Color of Object */,
  17 /* Group of ? */,
  7 /* Id of Sys */,
  4 /* Color of Sys */,
  51 /* Group of ? */,
  55 /* Id of Comparable */,
  5 /* Color of Comparable */,
  51 /* Group of ? */,
  147 /* Id of Discrete */,
  6 /* Color of Discrete */,
  62 /* Group of ? */,
  -13 /* Id of Bool */,
  4 /* Color of Bool */,
  46 /* Group of ? */,
  -9 /* Id of Float */,
  4 /* Color of Float */,
  47 /* Group of ? */,
  -37 /* Id of Int */,
  7 /* Color of Int */,
  71 /* Group of ? */,
  -41 /* Id of Char */,
  7 /* Color of Char */,
  68 /* Group of ? */,
  -1 /* Id of Pointer */,
  4 /* Color of Pointer */,
  46 /* Group of ? */,
};
const char LOCATE_standard___collection___list[] = "/home/jp/Projects-ssd/nit/lib/standard/collection/list.nit";
const int SFT_standard___collection___list[12] = {
  291 /* Id of List */,
  12 /* Color of List */,
  2 /* Group of ? */,
  99 /* Group of ? */,
  191 /* Id of ListIterator */,
  6 /* Color of ListIterator */,
  2 /* Group of ? */,
  53 /* Group of ? */,
  187 /* Id of ListNode */,
  8 /* Color of ListNode */,
  3 /* Group of ? */,
  78 /* Group of ? */,
};
const char LOCATE_standard___collection___sorter[] = "/home/jp/Projects-ssd/nit/lib/standard/collection/sorter.nit";
const int SFT_standard___collection___sorter[6] = {
  71 /* Id of AbstractSorter */,
  4 /* Color of AbstractSorter */,
  46 /* Group of ? */,
  163 /* Id of ComparableSorter */,
  5 /* Color of ComparableSorter */,
  52 /* Group of ? */,
};
const char LOCATE_standard___collection___array[] = "/home/jp/Projects-ssd/nit/lib/standard/collection/array.nit";
const int SFT_standard___collection___array[43] = {
  243 /* Id of AbstractArrayRead */,
  10 /* Color of AbstractArrayRead */,
  2 /* Group of ? */,
  82 /* Group of ? */,
  303 /* Id of AbstractArray */,
  13 /* Color of AbstractArray */,
  111 /* Group of ? */,
  311 /* Id of Array */,
  4 /* Color of Array */,
  3 /* Group of ? */,
  99 /* Group of ? */,
  239 /* Id of ArrayIterator */,
  6 /* Color of ArrayIterator */,
  2 /* Group of ? */,
  53 /* Group of ? */,
  299 /* Id of ArraySet */,
  10 /* Color of ArraySet */,
  2 /* Group of ? */,
  82 /* Group of ? */,
  171 /* Id of ArraySetIterator */,
  5 /* Color of ArraySetIterator */,
  2 /* Group of ? */,
  51 /* Group of ? */,
  275 /* Id of ArrayMap */,
  8 /* Color of ArrayMap */,
  2 /* Group of ? */,
  64 /* Group of ? */,
  235 /* Id of ArrayMapKeys */,
  9 /* Color of ArrayMapKeys */,
  2 /* Group of ? */,
  82 /* Group of ? */,
  231 /* Id of ArrayMapValues */,
  9 /* Color of ArrayMapValues */,
  2 /* Group of ? */,
  82 /* Group of ? */,
  46 /* Group of ? */,
  63 /* Group of ? */,
  67 /* Id of ArrayCapable */,
  5 /* Color of ArrayCapable */,
  55 /* Group of ? */,
  23 /* Id of NativeArray */,
  4 /* Color of NativeArray */,
  46 /* Group of ? */,
};
const char LOCATE_standard___collection___hash_collection[] = "/home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit";
const int SFT_standard___collection___hash_collection[38] = {
  135 /* Id of HashCollection */,
  7 /* Color of HashCollection */,
  2 /* Group of ? */,
  82 /* Group of ? */,
  47 /* Id of HashNode */,
  4 /* Color of HashNode */,
  2 /* Group of ? */,
  46 /* Group of ? */,
  211 /* Id of HashMap */,
  8 /* Color of HashMap */,
  9 /* Group of ? */,
  62 /* Group of ? */,
  207 /* Id of HashMapKeys */,
  9 /* Color of HashMapKeys */,
  2 /* Group of ? */,
  82 /* Group of ? */,
  203 /* Id of HashMapValues */,
  9 /* Color of HashMapValues */,
  2 /* Group of ? */,
  82 /* Group of ? */,
  127 /* Id of HashMapNode */,
  5 /* Color of HashMapNode */,
  7 /* Group of ? */,
  54 /* Group of ? */,
  131 /* Id of HashMapIterator */,
  5 /* Color of HashMapIterator */,
  2 /* Group of ? */,
  51 /* Group of ? */,
  295 /* Id of HashSet */,
  10 /* Color of HashSet */,
  51 /* Group of ? */,
  119 /* Id of HashSetNode */,
  5 /* Color of HashSetNode */,
  54 /* Group of ? */,
  123 /* Id of HashSetIterator */,
  5 /* Color of HashSetIterator */,
  2 /* Group of ? */,
  51 /* Group of ? */,
};
const char LOCATE_standard___hash[] = "/home/jp/Projects-ssd/nit/lib/standard/hash.nit";
const int SFT_standard___hash[1] = {
  41 /* Group of ? */,
};
const char LOCATE_standard___time[] = "/home/jp/Projects-ssd/nit/lib/standard/time.nit";
const int SFT_standard___time[2] = {
  16 /* Group of ? */,
  85 /* Group of ? */,
};
const char LOCATE_standard___file[] = "/home/jp/Projects-ssd/nit/lib/standard/file.nit";
const int SFT_standard___file[30] = {
  26 /* Group of ? */,
  139 /* Id of FStream */,
  4 /* Color of FStream */,
  2 /* Group of ? */,
  46 /* Group of ? */,
  267 /* Id of IFStream */,
  8 /* Color of IFStream */,
  6 /* Group of ? */,
  69 /* Group of ? */,
  183 /* Id of OFStream */,
  7 /* Color of OFStream */,
  4 /* Group of ? */,
  50 /* Group of ? */,
  287 /* Id of Stdin */,
  9 /* Color of Stdin */,
  74 /* Group of ? */,
  247 /* Id of Stdout */,
  8 /* Color of Stdout */,
  62 /* Group of ? */,
  251 /* Id of Stderr */,
  8 /* Color of Stderr */,
  62 /* Group of ? */,
  119 /* Group of ? */,
  54 /* Group of ? */,
  -25 /* Id of FileStat */,
  5 /* Color of FileStat */,
  47 /* Group of ? */,
  -21 /* Id of NativeFile */,
  5 /* Color of NativeFile */,
  47 /* Group of ? */,
};
const char LOCATE_standard___stream[] = "/home/jp/Projects-ssd/nit/lib/standard/stream.nit";
const int SFT_standard___stream[32] = {
  43 /* Id of IOS */,
  5 /* Color of IOS */,
  57 /* Group of ? */,
  115 /* Id of IStream */,
  7 /* Color of IStream */,
  62 /* Group of ? */,
  87 /* Id of OStream */,
  6 /* Color of OStream */,
  59 /* Group of ? */,
  227 /* Id of BufferedIStream */,
  6 /* Color of BufferedIStream */,
  4 /* Group of ? */,
  50 /* Group of ? */,
  199 /* Id of IOStream */,
  10 /* Color of IOStream */,
  79 /* Group of ? */,
  143 /* Id of FDStream */,
  4 /* Color of FDStream */,
  2 /* Group of ? */,
  46 /* Group of ? */,
  219 /* Id of FDIStream */,
  9 /* Color of FDIStream */,
  4 /* Group of ? */,
  69 /* Group of ? */,
  215 /* Id of FDOStream */,
  8 /* Color of FDOStream */,
  3 /* Group of ? */,
  54 /* Group of ? */,
  271 /* Id of FDIOStream */,
  11 /* Color of FDIOStream */,
  72 /* Group of ? */,
  33 /* Group of ? */,
};
const char LOCATE_standard___string_search[] = "/home/jp/Projects-ssd/nit/lib/standard/string_search.nit";
const int SFT_standard___string_search[12] = {
  19 /* Id of Pattern */,
  4 /* Color of Pattern */,
  46 /* Group of ? */,
  167 /* Id of BM_Pattern */,
  5 /* Color of BM_Pattern */,
  2 /* Group of ? */,
  51 /* Group of ? */,
  27 /* Id of Match */,
  4 /* Color of Match */,
  2 /* Group of ? */,
  46 /* Group of ? */,
  130 /* Group of ? */,
};
const char LOCATE_standard___exec[] = "/home/jp/Projects-ssd/nit/lib/standard/exec.nit";
const int SFT_standard___exec[20] = {
  15 /* Id of Process */,
  4 /* Color of Process */,
  2 /* Group of ? */,
  46 /* Group of ? */,
  195 /* Id of IProcess */,
  9 /* Color of IProcess */,
  4 /* Group of ? */,
  74 /* Group of ? */,
  179 /* Id of OProcess */,
  8 /* Color of OProcess */,
  3 /* Group of ? */,
  69 /* Group of ? */,
  263 /* Id of IOProcess */,
  11 /* Color of IOProcess */,
  80 /* Group of ? */,
  46 /* Group of ? */,
  58 /* Group of ? */,
  -17 /* Id of NativeProcess */,
  5 /* Color of NativeProcess */,
  47 /* Group of ? */,
};
const char LOCATE_standard___math[] = "/home/jp/Projects-ssd/nit/lib/standard/math.nit";
const int SFT_standard___math[4] = {
  87 /* Group of ? */,
  58 /* Group of ? */,
  73 /* Group of ? */,
  42 /* Group of ? */,
};
const char LOCATE_standard___gc[] = "/home/jp/Projects-ssd/nit/lib/standard/gc.nit";
const int SFT_standard___gc[1] = {
  54 /* Group of ? */,
};
const char LOCATE_test[] = "test.nit";
const classtable_elt_t VFT_event___ConnectionListener[55] = {
  {(bigint) -33 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "ConnectionListener" /* 2: Class Name */},
  {(bigint) 3 /* 3: ConnectionListener < Object: superclass typecheck marker */},
  {(bigint) -1 /* 4: ConnectionListener < Pointer: superclass typecheck marker */},
  {(bigint) 63 /* 5: ConnectionListener < Callback: superclass typecheck marker */},
  {(bigint) -33 /* 6: ConnectionListener < ConnectionListener: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 1 /* 17: ConnectionListener < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 2 /* 46: ConnectionListener < Pointer: superclass init_table position */},
  {(bigint) 0 /* 47: ConnectionListener < Callback: superclass init_table position */},
  {(bigint) event___Callback___accept_callback},
  {(bigint) event___ConnectionListener___error_callback},
  {(bigint) 3 /* 50: ConnectionListener < ConnectionListener: superclass init_table position */},
  {(bigint) event___ConnectionListener___bind_to},
  {(bigint) event___ConnectionListener___base},
  {(bigint) test___ConnectionListener___read_callback},
  {(bigint) event___ConnectionListener___exit_loop},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
val_t BOX_ConnectionListener(void* val) {
  struct TBOX_ConnectionListener *box = (struct TBOX_ConnectionListener*)alloc(sizeof(struct TBOX_ConnectionListener));
  box->vft = VFT_event___ConnectionListener;
  box->val = val;
  box->object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(box);
}
const classtable_elt_t VFT_standard___kernel___Sys[55] = {
  {(bigint) 7 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "Sys" /* 2: Class Name */},
  {(bigint) 3 /* 3: Sys < Object: superclass typecheck marker */},
  {(bigint) 7 /* 4: Sys < Sys: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 0 /* 17: Sys < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Sys___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) standard___exec___Sys___system},
  {(bigint) standard___string___Sys___program_name},
  {(bigint) standard___string___Sys___init_args},
  {(bigint) standard___string___Sys___native_argc},
  {(bigint) standard___string___Sys___native_argv},
  {(bigint) 1 /* 51: Sys < Sys: superclass init_table position */},
  {(bigint) event___Sys___main},
  {(bigint) standard___kernel___Sys___init},
  {(bigint) standard___gc___Sys___force_garbage_collection},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Sys::_args_cache */
static const char LOCATE_INIT_ATTRIBUTES__standard___kernel___Sys[] = "init var of Sys";
void INIT_ATTRIBUTES__standard___kernel___Sys(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___kernel___Sys;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___kernel___Sys(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_standard___kernel___Sys;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___kernel___Sys[] = "check new Sys";
void CHECKNEW_standard___kernel___Sys(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___kernel___Sys;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_Sys_standard___kernel___Sys___init[] = "new Sys kernel::Sys::init";
val_t NEW_Sys_standard___kernel___Sys___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[2] = {0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_NEW_Sys_standard___kernel___Sys___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = NEW_standard___kernel___Sys();
  INIT_ATTRIBUTES__standard___kernel___Sys(fra.me.REG[0]);
  standard___kernel___Sys___init(fra.me.REG[0], init_table);
  CHECKNEW_standard___kernel___Sys(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_standard___kernel___Bool[47] = {
  {(bigint) -13 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "Bool" /* 2: Class Name */},
  {(bigint) 3 /* 3: Bool < Object: superclass typecheck marker */},
  {(bigint) -13 /* 4: Bool < Bool: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 0 /* 17: Bool < Object: superclass init_table position */},
  {(bigint) standard___kernel___Bool___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Bool_____eqeq},
  {(bigint) standard___kernel___Bool_____neq},
  {(bigint) standard___kernel___Bool___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Bool___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Bool___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 1 /* 46: Bool < Bool: superclass init_table position */},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
const classtable_elt_t VFT_standard___kernel___Float[70] = {
  {(bigint) -9 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "Float" /* 2: Class Name */},
  {(bigint) 3 /* 3: Float < Object: superclass typecheck marker */},
  {(bigint) -9 /* 4: Float < Float: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 0 /* 17: Float < Object: superclass init_table position */},
  {(bigint) standard___kernel___Float___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Float___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Float___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) standard___string___Float___to_precision},
  {(bigint) 1 /* 47: Float < Float: superclass init_table position */},
  {(bigint) standard___kernel___Float_____leq},
  {(bigint) standard___kernel___Float_____l},
  {(bigint) standard___kernel___Float_____geq},
  {(bigint) standard___kernel___Float_____g},
  {(bigint) standard___kernel___Float_____plus},
  {(bigint) standard___kernel___Float___unary__minus},
  {(bigint) standard___kernel___Float_____minus},
  {(bigint) standard___kernel___Float_____star},
  {(bigint) standard___kernel___Float_____slash},
  {(bigint) standard___kernel___Float___to_i},
  {(bigint) standard___math___Float___sqrt},
  {(bigint) standard___math___Float___cos},
  {(bigint) standard___math___Float___sin},
  {(bigint) standard___math___Float___tan},
  {(bigint) standard___math___Float___acos},
  {(bigint) standard___math___Float___asin},
  {(bigint) standard___math___Float___atan},
  {(bigint) standard___math___Float___pow},
  {(bigint) standard___math___Float___log},
  {(bigint) standard___math___Float___exp},
  {(bigint) standard___math___Float___rand},
  {(bigint) standard___math___Float___hypot_with},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
val_t BOX_Float(float val) {
  struct TBOX_Float *box = (struct TBOX_Float*)alloc(sizeof(struct TBOX_Float));
  box->vft = VFT_standard___kernel___Float;
  box->val = val;
  box->object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(box);
}
const classtable_elt_t VFT_standard___kernel___Int[88] = {
  {(bigint) -37 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "Int" /* 2: Class Name */},
  {(bigint) 3 /* 3: Int < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 55 /* 5: Int < Comparable: superclass typecheck marker */},
  {(bigint) 147 /* 6: Int < Discrete: superclass typecheck marker */},
  {(bigint) -37 /* 7: Int < Int: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 2 /* 17: Int < Object: superclass init_table position */},
  {(bigint) standard___kernel___Int___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Int_____eqeq},
  {(bigint) standard___kernel___Int_____neq},
  {(bigint) standard___kernel___Int___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Int___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Int___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 51: Int < Comparable: superclass init_table position */},
  {(bigint) -37 /* 52: VT Int::OTHER : id of Int */},
  {(bigint) 7 /* 53: VT Int::OTHER : color of Int */},
  {(bigint) standard___kernel___Int_____l},
  {(bigint) standard___kernel___Int_____leq},
  {(bigint) standard___kernel___Int_____geq},
  {(bigint) standard___kernel___Int_____g},
  {(bigint) standard___kernel___Int_____leqg},
  {(bigint) standard___kernel___Int___is_between},
  {(bigint) standard___kernel___Int___max},
  {(bigint) standard___kernel___Int___min},
  {(bigint) 0 /* 62: Int < Discrete: superclass init_table position */},
  {(bigint) standard___kernel___Int___succ},
  {(bigint) standard___kernel___Int___prec},
  {(bigint) standard___kernel___Int_____plus},
  {(bigint) standard___kernel___Int_____minus},
  {(bigint) standard___kernel___Int___distance},
  {(bigint) standard___string___Int___fill_buffer},
  {(bigint) standard___string___Int___to_hex},
  {(bigint) standard___string___Int___to_base},
  {(bigint) 3 /* 71: Int < Int: superclass init_table position */},
  {(bigint) standard___kernel___Int___unary__minus},
  {(bigint) standard___kernel___Int_____star},
  {(bigint) standard___kernel___Int_____slash},
  {(bigint) standard___kernel___Int_____percent},
  {(bigint) standard___kernel___Int___lshift},
  {(bigint) standard___kernel___Int___rshift},
  {(bigint) standard___kernel___Int___to_f},
  {(bigint) standard___kernel___Int___ascii},
  {(bigint) standard___kernel___Int___digit_count},
  {(bigint) standard___kernel___Int___to_c},
  {(bigint) standard___kernel___Int___enumerate_to},
  {(bigint) standard___kernel___Int___enumerate_before},
  {(bigint) standard___kernel___Int___abs},
  {(bigint) standard___time___Int___sleep},
  {(bigint) standard___time___Int___nanosleep},
  {(bigint) standard___math___Int___rand},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
const classtable_elt_t VFT_standard___kernel___Char[77] = {
  {(bigint) -41 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "Char" /* 2: Class Name */},
  {(bigint) 3 /* 3: Char < Object: superclass typecheck marker */},
  {(bigint) 19 /* 4: Char < Pattern: superclass typecheck marker */},
  {(bigint) 55 /* 5: Char < Comparable: superclass typecheck marker */},
  {(bigint) 147 /* 6: Char < Discrete: superclass typecheck marker */},
  {(bigint) -41 /* 7: Char < Char: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 1 /* 17: Char < Object: superclass init_table position */},
  {(bigint) standard___kernel___Char___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Char_____eqeq},
  {(bigint) standard___kernel___Char_____neq},
  {(bigint) standard___kernel___Char___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Char___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Char___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 0 /* 46: Char < Pattern: superclass init_table position */},
  {(bigint) standard___string_search___Char___search_index_in},
  {(bigint) standard___string_search___Char___search_in},
  {(bigint) standard___string_search___Pattern___search_all_in},
  {(bigint) standard___string_search___Pattern___split_in},
  {(bigint) 3 /* 51: Char < Comparable: superclass init_table position */},
  {(bigint) -41 /* 52: VT Char::OTHER : id of Char */},
  {(bigint) 7 /* 53: VT Char::OTHER : color of Char */},
  {(bigint) standard___kernel___Char_____l},
  {(bigint) standard___kernel___Char_____leq},
  {(bigint) standard___kernel___Char_____geq},
  {(bigint) standard___kernel___Char_____g},
  {(bigint) standard___kernel___Comparable_____leqg},
  {(bigint) standard___kernel___Comparable___is_between},
  {(bigint) standard___kernel___Comparable___max},
  {(bigint) standard___kernel___Comparable___min},
  {(bigint) 2 /* 62: Char < Discrete: superclass init_table position */},
  {(bigint) standard___kernel___Char___succ},
  {(bigint) standard___kernel___Char___prec},
  {(bigint) standard___kernel___Char_____plus},
  {(bigint) standard___kernel___Char_____minus},
  {(bigint) standard___kernel___Char___distance},
  {(bigint) 4 /* 68: Char < Char: superclass init_table position */},
  {(bigint) standard___kernel___Char___to_i},
  {(bigint) standard___kernel___Char___ascii},
  {(bigint) standard___kernel___Char___to_lower},
  {(bigint) standard___kernel___Char___to_upper},
  {(bigint) standard___kernel___Char___is_digit},
  {(bigint) standard___kernel___Char___is_lower},
  {(bigint) standard___kernel___Char___is_upper},
  {(bigint) standard___kernel___Char___is_letter},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
const classtable_elt_t VFT_standard___kernel___Pointer[47] = {
  {(bigint) -1 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "Pointer" /* 2: Class Name */},
  {(bigint) 3 /* 3: Pointer < Object: superclass typecheck marker */},
  {(bigint) -1 /* 4: Pointer < Pointer: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 0 /* 17: Pointer < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 1 /* 46: Pointer < Pointer: superclass init_table position */},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
val_t BOX_Pointer(void * val) {
  struct TBOX_Pointer *box = (struct TBOX_Pointer*)alloc(sizeof(struct TBOX_Pointer));
  box->vft = VFT_standard___kernel___Pointer;
  box->val = val;
  box->object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(box);
}
const classtable_elt_t VFT_standard___collection___abstract_collection___Container[78] = {
  {(bigint) 159 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "Container" /* 2: Class Name */},
  {(bigint) 3 /* 3: Container < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 59 /* 6: Container < Collection: superclass typecheck marker */},
  {(bigint) 159 /* 7: Container < Container: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 1 /* 17: Container < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Collection___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___string___Collection___join},
  {(bigint) standard___collection___array___Collection___to_a},
  {(bigint) 0 /* 64: Container < Collection: superclass init_table position */},
  {(bigint) standard___collection___abstract_collection___Container___iterator},
  {(bigint) standard___collection___abstract_collection___Collection___iterate},
  {(bigint) standard___collection___abstract_collection___Container___is_empty},
  {(bigint) standard___collection___abstract_collection___Container___length},
  {(bigint) standard___collection___abstract_collection___Container___has},
  {(bigint) standard___collection___abstract_collection___Container___has_only},
  {(bigint) standard___collection___abstract_collection___Container___count},
  {(bigint) standard___collection___abstract_collection___Container___first},
  {(bigint) standard___math___Collection___rand},
  {(bigint) 2 /* 74: Container < Container: superclass init_table position */},
  {(bigint) standard___collection___abstract_collection___Container___init},
  {(bigint) standard___collection___abstract_collection___Container___item},
  {(bigint) standard___collection___abstract_collection___Container___item__eq},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Container::_item */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___abstract_collection___Container[] = "init var of Container";
void INIT_ATTRIBUTES__standard___collection___abstract_collection___Container(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___abstract_collection___Container;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___abstract_collection___Container(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___abstract_collection___Container;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___abstract_collection___Container[] = "check new Container";
void CHECKNEW_standard___collection___abstract_collection___Container(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___abstract_collection___Container;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_Container_standard___collection___abstract_collection___Container___init[] = "new Container abstract_collection::Container::init";
val_t NEW_Container_standard___collection___abstract_collection___Container___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 158;
  fra.me.meth = LOCATE_NEW_Container_standard___collection___abstract_collection___Container___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/abstract_collection.nit:158 */
  fra.me.REG[1] = NEW_standard___collection___abstract_collection___Container();
  INIT_ATTRIBUTES__standard___collection___abstract_collection___Container(fra.me.REG[1]);
  standard___collection___abstract_collection___Container___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___abstract_collection___Container(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___collection___abstract_collection___ContainerIterator[53] = {
  {(bigint) 155 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "ContainerIterator" /* 2: Class Name */},
  {(bigint) 3 /* 3: ContainerIterator < Object: superclass typecheck marker */},
  {(bigint) 39 /* 4: ContainerIterator < Iterator: superclass typecheck marker */},
  {(bigint) 155 /* 5: ContainerIterator < ContainerIterator: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 1 /* 17: ContainerIterator < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) standard___collection___array___Iterator___to_a},
  {(bigint) 0 /* 47: ContainerIterator < Iterator: superclass init_table position */},
  {(bigint) standard___collection___abstract_collection___ContainerIterator___item},
  {(bigint) standard___collection___abstract_collection___ContainerIterator___next},
  {(bigint) standard___collection___abstract_collection___ContainerIterator___is_ok},
  {(bigint) 2 /* 51: ContainerIterator < ContainerIterator: superclass init_table position */},
  {(bigint) standard___collection___abstract_collection___ContainerIterator___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute ContainerIterator::_is_ok */
/* 3: Attribute ContainerIterator::_container */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___abstract_collection___ContainerIterator[] = "init var of ContainerIterator";
void INIT_ATTRIBUTES__standard___collection___abstract_collection___ContainerIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___abstract_collection___ContainerIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/abstract_collection.nit:174 */
  REGB0 = TAG_Bool(1);
  ATTR_standard___collection___abstract_collection___ContainerIterator____is_ok(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___abstract_collection___ContainerIterator(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___abstract_collection___ContainerIterator;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___abstract_collection___ContainerIterator[] = "check new ContainerIterator";
void CHECKNEW_standard___collection___abstract_collection___ContainerIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___abstract_collection___ContainerIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___abstract_collection___ContainerIterator____is_ok(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_is_ok", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___collection___abstract_collection___ContainerIterator____container(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_container", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_ContainerIterator_standard___collection___abstract_collection___ContainerIterator___init[] = "new ContainerIterator abstract_collection::ContainerIterator::init";
val_t NEW_ContainerIterator_standard___collection___abstract_collection___ContainerIterator___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 172;
  fra.me.meth = LOCATE_NEW_ContainerIterator_standard___collection___abstract_collection___ContainerIterator___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/abstract_collection.nit:172 */
  fra.me.REG[1] = NEW_standard___collection___abstract_collection___ContainerIterator();
  INIT_ATTRIBUTES__standard___collection___abstract_collection___ContainerIterator(fra.me.REG[1]);
  standard___collection___abstract_collection___ContainerIterator___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___abstract_collection___ContainerIterator(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___collection___abstract_collection___MapKeysIterator[55] = {
  {(bigint) 99 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "MapKeysIterator" /* 2: Class Name */},
  {(bigint) 3 /* 3: MapKeysIterator < Object: superclass typecheck marker */},
  {(bigint) 39 /* 4: MapKeysIterator < Iterator: superclass typecheck marker */},
  {(bigint) 99 /* 5: MapKeysIterator < MapKeysIterator: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 1 /* 17: MapKeysIterator < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) standard___collection___array___Iterator___to_a},
  {(bigint) 0 /* 47: MapKeysIterator < Iterator: superclass init_table position */},
  {(bigint) standard___collection___abstract_collection___MapKeysIterator___item},
  {(bigint) standard___collection___abstract_collection___MapKeysIterator___next},
  {(bigint) standard___collection___abstract_collection___MapKeysIterator___is_ok},
  {(bigint) 2 /* 51: MapKeysIterator < MapKeysIterator: superclass init_table position */},
  {(bigint) standard___collection___abstract_collection___MapKeysIterator___iterator},
  {(bigint) standard___collection___abstract_collection___MapKeysIterator___iterator__eq},
  {(bigint) standard___collection___abstract_collection___MapKeysIterator___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute MapKeysIterator::@iterator */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___abstract_collection___MapKeysIterator[] = "init var of MapKeysIterator";
void INIT_ATTRIBUTES__standard___collection___abstract_collection___MapKeysIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___abstract_collection___MapKeysIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___abstract_collection___MapKeysIterator(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___abstract_collection___MapKeysIterator;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___abstract_collection___MapKeysIterator[] = "check new MapKeysIterator";
void CHECKNEW_standard___collection___abstract_collection___MapKeysIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___abstract_collection___MapKeysIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___abstract_collection___MapKeysIterator_____atiterator(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@iterator", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_MapKeysIterator_standard___collection___abstract_collection___MapKeysIterator___init[] = "new MapKeysIterator abstract_collection::MapKeysIterator::init";
val_t NEW_MapKeysIterator_standard___collection___abstract_collection___MapKeysIterator___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_NEW_MapKeysIterator_standard___collection___abstract_collection___MapKeysIterator___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = NEW_standard___collection___abstract_collection___MapKeysIterator();
  INIT_ATTRIBUTES__standard___collection___abstract_collection___MapKeysIterator(fra.me.REG[1]);
  standard___collection___abstract_collection___MapKeysIterator___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___abstract_collection___MapKeysIterator(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___collection___abstract_collection___MapValuesIterator[55] = {
  {(bigint) 95 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "MapValuesIterator" /* 2: Class Name */},
  {(bigint) 3 /* 3: MapValuesIterator < Object: superclass typecheck marker */},
  {(bigint) 39 /* 4: MapValuesIterator < Iterator: superclass typecheck marker */},
  {(bigint) 95 /* 5: MapValuesIterator < MapValuesIterator: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 1 /* 17: MapValuesIterator < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) standard___collection___array___Iterator___to_a},
  {(bigint) 0 /* 47: MapValuesIterator < Iterator: superclass init_table position */},
  {(bigint) standard___collection___abstract_collection___MapValuesIterator___item},
  {(bigint) standard___collection___abstract_collection___MapValuesIterator___next},
  {(bigint) standard___collection___abstract_collection___MapValuesIterator___is_ok},
  {(bigint) 2 /* 51: MapValuesIterator < MapValuesIterator: superclass init_table position */},
  {(bigint) standard___collection___abstract_collection___MapValuesIterator___iterator},
  {(bigint) standard___collection___abstract_collection___MapValuesIterator___iterator__eq},
  {(bigint) standard___collection___abstract_collection___MapValuesIterator___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute MapValuesIterator::@iterator */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___abstract_collection___MapValuesIterator[] = "init var of MapValuesIterator";
void INIT_ATTRIBUTES__standard___collection___abstract_collection___MapValuesIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___abstract_collection___MapValuesIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___abstract_collection___MapValuesIterator(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___abstract_collection___MapValuesIterator;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___abstract_collection___MapValuesIterator[] = "check new MapValuesIterator";
void CHECKNEW_standard___collection___abstract_collection___MapValuesIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___abstract_collection___MapValuesIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___abstract_collection___MapValuesIterator_____atiterator(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@iterator", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_MapValuesIterator_standard___collection___abstract_collection___MapValuesIterator___init[] = "new MapValuesIterator abstract_collection::MapValuesIterator::init";
val_t NEW_MapValuesIterator_standard___collection___abstract_collection___MapValuesIterator___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_NEW_MapValuesIterator_standard___collection___abstract_collection___MapValuesIterator___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = NEW_standard___collection___abstract_collection___MapValuesIterator();
  INIT_ATTRIBUTES__standard___collection___abstract_collection___MapValuesIterator(fra.me.REG[1]);
  standard___collection___abstract_collection___MapValuesIterator___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___abstract_collection___MapValuesIterator(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___collection___abstract_collection___CoupleMapIterator[53] = {
  {(bigint) 151 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "CoupleMapIterator" /* 2: Class Name */},
  {(bigint) 3 /* 3: CoupleMapIterator < Object: superclass typecheck marker */},
  {(bigint) 35 /* 4: CoupleMapIterator < MapIterator: superclass typecheck marker */},
  {(bigint) 151 /* 5: CoupleMapIterator < CoupleMapIterator: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 1 /* 17: CoupleMapIterator < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 0 /* 46: CoupleMapIterator < MapIterator: superclass init_table position */},
  {(bigint) standard___collection___abstract_collection___CoupleMapIterator___item},
  {(bigint) standard___collection___abstract_collection___CoupleMapIterator___key},
  {(bigint) standard___collection___abstract_collection___CoupleMapIterator___next},
  {(bigint) standard___collection___abstract_collection___CoupleMapIterator___is_ok},
  {(bigint) 2 /* 51: CoupleMapIterator < CoupleMapIterator: superclass init_table position */},
  {(bigint) standard___collection___abstract_collection___CoupleMapIterator___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute CoupleMapIterator::_iter */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___abstract_collection___CoupleMapIterator[] = "init var of CoupleMapIterator";
void INIT_ATTRIBUTES__standard___collection___abstract_collection___CoupleMapIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___abstract_collection___CoupleMapIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___abstract_collection___CoupleMapIterator(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___abstract_collection___CoupleMapIterator;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___abstract_collection___CoupleMapIterator[] = "check new CoupleMapIterator";
void CHECKNEW_standard___collection___abstract_collection___CoupleMapIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___abstract_collection___CoupleMapIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___abstract_collection___CoupleMapIterator____iter(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_iter", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_CoupleMapIterator_standard___collection___abstract_collection___CoupleMapIterator___init[] = "new CoupleMapIterator abstract_collection::CoupleMapIterator::init";
val_t NEW_CoupleMapIterator_standard___collection___abstract_collection___CoupleMapIterator___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 504;
  fra.me.meth = LOCATE_NEW_CoupleMapIterator_standard___collection___abstract_collection___CoupleMapIterator___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/abstract_collection.nit:504 */
  fra.me.REG[1] = NEW_standard___collection___abstract_collection___CoupleMapIterator();
  INIT_ATTRIBUTES__standard___collection___abstract_collection___CoupleMapIterator(fra.me.REG[1]);
  standard___collection___abstract_collection___CoupleMapIterator___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___abstract_collection___CoupleMapIterator(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___collection___abstract_collection___Couple[52] = {
  {(bigint) 51 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "Couple" /* 2: Class Name */},
  {(bigint) 3 /* 3: Couple < Object: superclass typecheck marker */},
  {(bigint) 51 /* 4: Couple < Couple: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 0 /* 17: Couple < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 1 /* 46: Couple < Couple: superclass init_table position */},
  {(bigint) standard___collection___abstract_collection___Couple___first},
  {(bigint) standard___collection___abstract_collection___Couple___first__eq},
  {(bigint) standard___collection___abstract_collection___Couple___second},
  {(bigint) standard___collection___abstract_collection___Couple___second__eq},
  {(bigint) standard___collection___abstract_collection___Couple___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Couple::_first */
/* 3: Attribute Couple::_second */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___abstract_collection___Couple[] = "init var of Couple";
void INIT_ATTRIBUTES__standard___collection___abstract_collection___Couple(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___abstract_collection___Couple;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___abstract_collection___Couple(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___abstract_collection___Couple;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___abstract_collection___Couple[] = "check new Couple";
void CHECKNEW_standard___collection___abstract_collection___Couple(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___abstract_collection___Couple;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_Couple_standard___collection___abstract_collection___Couple___init[] = "new Couple abstract_collection::Couple::init";
val_t NEW_Couple_standard___collection___abstract_collection___Couple___init(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[2];} fra;
  val_t tmp;
  int init_table[2] = {0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 518;
  fra.me.meth = LOCATE_NEW_Couple_standard___collection___abstract_collection___Couple___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 3;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[2] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = p1;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/abstract_collection.nit:518 */
  fra.me.REG[2] = NEW_standard___collection___abstract_collection___Couple();
  INIT_ATTRIBUTES__standard___collection___abstract_collection___Couple(fra.me.REG[2]);
  standard___collection___abstract_collection___Couple___init(fra.me.REG[2], fra.me.REG[0], fra.me.REG[1], init_table);
  CHECKNEW_standard___collection___abstract_collection___Couple(fra.me.REG[2]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[2];
}
const classtable_elt_t VFT_standard___collection___range___Range[79] = {
  {(bigint) 83 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "Range" /* 2: Class Name */},
  {(bigint) 3 /* 3: Range < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 59 /* 6: Range < Collection: superclass typecheck marker */},
  {(bigint) 83 /* 7: Range < Range: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 1 /* 17: Range < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Collection___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___string___Collection___join},
  {(bigint) standard___collection___array___Collection___to_a},
  {(bigint) 0 /* 64: Range < Collection: superclass init_table position */},
  {(bigint) standard___collection___range___Range___iterator},
  {(bigint) standard___collection___range___Range___iterate},
  {(bigint) standard___collection___range___Range___is_empty},
  {(bigint) standard___collection___range___Range___length},
  {(bigint) standard___collection___range___Range___has},
  {(bigint) standard___collection___range___Range___has_only},
  {(bigint) standard___collection___range___Range___count},
  {(bigint) standard___collection___range___Range___first},
  {(bigint) standard___math___Collection___rand},
  {(bigint) 2 /* 74: Range < Range: superclass init_table position */},
  {(bigint) standard___collection___range___Range___last},
  {(bigint) standard___collection___range___Range___after},
  {(bigint) standard___collection___range___Range___init},
  {(bigint) standard___collection___range___Range___without_last},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Range::_first */
/* 3: Attribute Range::_last */
/* 4: Attribute Range::_after */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___range___Range[] = "init var of Range";
void INIT_ATTRIBUTES__standard___collection___range___Range(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___range___Range;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___range___Range(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___range___Range;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___range___Range[] = "check new Range";
void CHECKNEW_standard___collection___range___Range(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___range___Range;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___range___Range____first(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_first", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___collection___range___Range____last(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_last", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___collection___range___Range____after(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_after", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_Range_standard___collection___range___Range___init[] = "new Range range::Range::init";
val_t NEW_Range_standard___collection___range___Range___init(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[2];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 68;
  fra.me.meth = LOCATE_NEW_Range_standard___collection___range___Range___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 3;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[2] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = p1;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/range.nit:68 */
  fra.me.REG[2] = NEW_standard___collection___range___Range();
  INIT_ATTRIBUTES__standard___collection___range___Range(fra.me.REG[2]);
  standard___collection___range___Range___init(fra.me.REG[2], fra.me.REG[0], fra.me.REG[1], init_table);
  CHECKNEW_standard___collection___range___Range(fra.me.REG[2]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[2];
}
static const char LOCATE_NEW_Range_standard___collection___range___Range___without_last[] = "new Range range::Range::without_last";
val_t NEW_Range_standard___collection___range___Range___without_last(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[2];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 77;
  fra.me.meth = LOCATE_NEW_Range_standard___collection___range___Range___without_last;
  fra.me.has_broke = 0;
  fra.me.REG_size = 3;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[2] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = p1;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/range.nit:77 */
  fra.me.REG[2] = NEW_standard___collection___range___Range();
  INIT_ATTRIBUTES__standard___collection___range___Range(fra.me.REG[2]);
  standard___collection___range___Range___without_last(fra.me.REG[2], fra.me.REG[0], fra.me.REG[1], init_table);
  CHECKNEW_standard___collection___range___Range(fra.me.REG[2]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[2];
}
const classtable_elt_t VFT_standard___collection___range___IteratorRange[53] = {
  {(bigint) 107 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "IteratorRange" /* 2: Class Name */},
  {(bigint) 3 /* 3: IteratorRange < Object: superclass typecheck marker */},
  {(bigint) 39 /* 4: IteratorRange < Iterator: superclass typecheck marker */},
  {(bigint) 107 /* 5: IteratorRange < IteratorRange: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 1 /* 17: IteratorRange < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) standard___collection___array___Iterator___to_a},
  {(bigint) 0 /* 47: IteratorRange < Iterator: superclass init_table position */},
  {(bigint) standard___collection___range___IteratorRange___item},
  {(bigint) standard___collection___range___IteratorRange___next},
  {(bigint) standard___collection___range___IteratorRange___is_ok},
  {(bigint) 2 /* 51: IteratorRange < IteratorRange: superclass init_table position */},
  {(bigint) standard___collection___range___IteratorRange___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute IteratorRange::_range */
/* 3: Attribute IteratorRange::_item */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___range___IteratorRange[] = "init var of IteratorRange";
void INIT_ATTRIBUTES__standard___collection___range___IteratorRange(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___range___IteratorRange;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___range___IteratorRange(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___range___IteratorRange;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___range___IteratorRange[] = "check new IteratorRange";
void CHECKNEW_standard___collection___range___IteratorRange(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___range___IteratorRange;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___range___IteratorRange____range(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_range", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___collection___range___IteratorRange____item(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_item", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_IteratorRange_standard___collection___range___IteratorRange___init[] = "new IteratorRange range::IteratorRange::init";
val_t NEW_IteratorRange_standard___collection___range___IteratorRange___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 97;
  fra.me.meth = LOCATE_NEW_IteratorRange_standard___collection___range___IteratorRange___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/range.nit:97 */
  fra.me.REG[1] = NEW_standard___collection___range___IteratorRange();
  INIT_ATTRIBUTES__standard___collection___range___IteratorRange(fra.me.REG[1]);
  standard___collection___range___IteratorRange___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___range___IteratorRange(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___collection___list___List[107] = {
  {(bigint) 291 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "List" /* 2: Class Name */},
  {(bigint) 3 /* 3: List < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 59 /* 6: List < Collection: superclass typecheck marker */},
  {(bigint) 75 /* 7: List < SequenceRead: superclass typecheck marker */},
  {(bigint) 79 /* 8: List < RemovableCollection: superclass typecheck marker */},
  {(bigint) 175 /* 9: List < SimpleCollection: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 259 /* 11: List < Sequence: superclass typecheck marker */},
  {(bigint) 291 /* 12: List < List: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 5 /* 17: List < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Collection___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 2 /* 48: List < SimpleCollection: superclass init_table position */},
  {(bigint) standard___collection___abstract_collection___Sequence___add},
  {(bigint) standard___collection___abstract_collection___SimpleCollection___add_all},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___string___Collection___join},
  {(bigint) standard___collection___array___Collection___to_a},
  {(bigint) 4 /* 64: List < Collection: superclass init_table position */},
  {(bigint) standard___collection___list___List___iterator},
  {(bigint) standard___collection___abstract_collection___Collection___iterate},
  {(bigint) standard___collection___list___List___is_empty},
  {(bigint) standard___collection___list___List___length},
  {(bigint) standard___collection___list___List___has},
  {(bigint) standard___collection___list___List___has_only},
  {(bigint) standard___collection___list___List___count},
  {(bigint) standard___collection___list___List___first},
  {(bigint) standard___math___Collection___rand},
  {(bigint) 1 /* 74: List < SequenceRead: superclass init_table position */},
  {(bigint) standard___collection___list___List_____bra},
  {(bigint) standard___collection___list___List___last},
  {(bigint) standard___collection___abstract_collection___SequenceRead___index_of},
  {(bigint) 3 /* 78: List < RemovableCollection: superclass init_table position */},
  {(bigint) standard___collection___list___List___clear},
  {(bigint) standard___collection___list___List___remove},
  {(bigint) standard___collection___abstract_collection___RemovableCollection___remove_all},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 0 /* 89: List < Sequence: superclass init_table position */},
  {(bigint) standard___collection___list___List___first__eq},
  {(bigint) standard___collection___list___List___last__eq},
  {(bigint) standard___collection___list___List___push},
  {(bigint) standard___collection___abstract_collection___Sequence___append},
  {(bigint) standard___collection___list___List___pop},
  {(bigint) standard___collection___list___List___unshift},
  {(bigint) standard___collection___list___List___shift},
  {(bigint) standard___collection___list___List_____braeq},
  {(bigint) standard___collection___list___List___remove_at},
  {(bigint) 6 /* 99: List < List: superclass init_table position */},
  {(bigint) standard___collection___list___List___link},
  {(bigint) standard___collection___list___List___init},
  {(bigint) standard___collection___list___List___from},
  {(bigint) standard___collection___list___List___get_node},
  {(bigint) standard___collection___list___List___search_node_after},
  {(bigint) standard___collection___list___List___remove_node},
  {(bigint) standard___collection___list___List___insert_before},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute List::_head */
/* 3: Attribute List::_tail */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___list___List[] = "init var of List";
void INIT_ATTRIBUTES__standard___collection___list___List(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___list___List;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___list___List(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___list___List;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___list___List[] = "check new List";
void CHECKNEW_standard___collection___list___List(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___list___List;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_List_standard___collection___list___List___init[] = "new List list::List::init";
val_t NEW_List_standard___collection___list___List___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[7] = {0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 173;
  fra.me.meth = LOCATE_NEW_List_standard___collection___list___List___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/list.nit:173 */
  fra.me.REG[0] = NEW_standard___collection___list___List();
  INIT_ATTRIBUTES__standard___collection___list___List(fra.me.REG[0]);
  standard___collection___list___List___init(fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___list___List(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
static const char LOCATE_NEW_List_standard___collection___list___List___from[] = "new List list::List::from";
val_t NEW_List_standard___collection___list___List___from(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[7] = {0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 176;
  fra.me.meth = LOCATE_NEW_List_standard___collection___list___List___from;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/list.nit:176 */
  fra.me.REG[1] = NEW_standard___collection___list___List();
  INIT_ATTRIBUTES__standard___collection___list___List(fra.me.REG[1]);
  standard___collection___list___List___from(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___list___List(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___collection___list___ListIterator[58] = {
  {(bigint) 191 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "ListIterator" /* 2: Class Name */},
  {(bigint) 3 /* 3: ListIterator < Object: superclass typecheck marker */},
  {(bigint) 39 /* 4: ListIterator < Iterator: superclass typecheck marker */},
  {(bigint) 111 /* 5: ListIterator < IndexedIterator: superclass typecheck marker */},
  {(bigint) 191 /* 6: ListIterator < ListIterator: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 2 /* 17: ListIterator < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) standard___collection___array___Iterator___to_a},
  {(bigint) 1 /* 47: ListIterator < Iterator: superclass init_table position */},
  {(bigint) standard___collection___list___ListIterator___item},
  {(bigint) standard___collection___list___ListIterator___next},
  {(bigint) standard___collection___list___ListIterator___is_ok},
  {(bigint) 0 /* 51: ListIterator < IndexedIterator: superclass init_table position */},
  {(bigint) standard___collection___list___ListIterator___index},
  {(bigint) 3 /* 53: ListIterator < ListIterator: superclass init_table position */},
  {(bigint) standard___collection___list___ListIterator___item__eq},
  {(bigint) standard___collection___list___ListIterator___init},
  {(bigint) standard___collection___list___ListIterator___delete},
  {(bigint) standard___collection___list___ListIterator___insert_before},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute ListIterator::_list */
/* 3: Attribute ListIterator::_node */
/* 4: Attribute ListIterator::_index */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___list___ListIterator[] = "init var of ListIterator";
void INIT_ATTRIBUTES__standard___collection___list___ListIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___list___ListIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___list___ListIterator(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___list___ListIterator;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___list___ListIterator[] = "check new ListIterator";
void CHECKNEW_standard___collection___list___ListIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___list___ListIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___list___ListIterator____list(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_list", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___collection___list___ListIterator____index(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_index", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_ListIterator_standard___collection___list___ListIterator___init[] = "new ListIterator list::ListIterator::init";
val_t NEW_ListIterator_standard___collection___list___ListIterator___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[4] = {0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 256;
  fra.me.meth = LOCATE_NEW_ListIterator_standard___collection___list___ListIterator___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/list.nit:256 */
  fra.me.REG[1] = NEW_standard___collection___list___ListIterator();
  INIT_ATTRIBUTES__standard___collection___list___ListIterator(fra.me.REG[1]);
  standard___collection___list___ListIterator___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___list___ListIterator(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___collection___list___ListNode[84] = {
  {(bigint) 187 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "ListNode" /* 2: Class Name */},
  {(bigint) 3 /* 3: ListNode < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 59 /* 6: ListNode < Collection: superclass typecheck marker */},
  {(bigint) 159 /* 7: ListNode < Container: superclass typecheck marker */},
  {(bigint) 187 /* 8: ListNode < ListNode: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 1 /* 17: ListNode < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Collection___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___string___Collection___join},
  {(bigint) standard___collection___array___Collection___to_a},
  {(bigint) 0 /* 64: ListNode < Collection: superclass init_table position */},
  {(bigint) standard___collection___abstract_collection___Container___iterator},
  {(bigint) standard___collection___abstract_collection___Collection___iterate},
  {(bigint) standard___collection___abstract_collection___Container___is_empty},
  {(bigint) standard___collection___abstract_collection___Container___length},
  {(bigint) standard___collection___abstract_collection___Container___has},
  {(bigint) standard___collection___abstract_collection___Container___has_only},
  {(bigint) standard___collection___abstract_collection___Container___count},
  {(bigint) standard___collection___abstract_collection___Container___first},
  {(bigint) standard___math___Collection___rand},
  {(bigint) 2 /* 74: ListNode < Container: superclass init_table position */},
  {(bigint) standard___collection___abstract_collection___Container___init},
  {(bigint) standard___collection___abstract_collection___Container___item},
  {(bigint) standard___collection___abstract_collection___Container___item__eq},
  {(bigint) 3 /* 78: ListNode < ListNode: superclass init_table position */},
  {(bigint) standard___collection___list___ListNode___init},
  {(bigint) standard___collection___list___ListNode___next},
  {(bigint) standard___collection___list___ListNode___next__eq},
  {(bigint) standard___collection___list___ListNode___prev},
  {(bigint) standard___collection___list___ListNode___prev__eq},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute ListNode::_item */
/* 3: Attribute ListNode::_next */
/* 4: Attribute ListNode::_prev */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___list___ListNode[] = "init var of ListNode";
void INIT_ATTRIBUTES__standard___collection___list___ListNode(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___list___ListNode;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___list___ListNode(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___list___ListNode;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___list___ListNode[] = "check new ListNode";
void CHECKNEW_standard___collection___list___ListNode(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___list___ListNode;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_ListNode_standard___collection___list___ListNode___init[] = "new ListNode list::ListNode::init";
val_t NEW_ListNode_standard___collection___list___ListNode___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[4] = {0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 289;
  fra.me.meth = LOCATE_NEW_ListNode_standard___collection___list___ListNode___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/list.nit:289 */
  fra.me.REG[1] = NEW_standard___collection___list___ListNode();
  INIT_ATTRIBUTES__standard___collection___list___ListNode(fra.me.REG[1]);
  standard___collection___list___ListNode___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___list___ListNode(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___collection___array___Array[115] = {
  {(bigint) 311 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "Array" /* 2: Class Name */},
  {(bigint) 3 /* 3: Array < Object: superclass typecheck marker */},
  {(bigint) 311 /* 4: Array < Array: superclass typecheck marker */},
  {(bigint) 67 /* 5: Array < ArrayCapable: superclass typecheck marker */},
  {(bigint) 59 /* 6: Array < Collection: superclass typecheck marker */},
  {(bigint) 75 /* 7: Array < SequenceRead: superclass typecheck marker */},
  {(bigint) 79 /* 8: Array < RemovableCollection: superclass typecheck marker */},
  {(bigint) 175 /* 9: Array < SimpleCollection: superclass typecheck marker */},
  {(bigint) 243 /* 10: Array < AbstractArrayRead: superclass typecheck marker */},
  {(bigint) 259 /* 11: Array < Sequence: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 303 /* 13: Array < AbstractArray: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 7 /* 17: Array < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___collection___array___AbstractArrayRead_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___collection___array___AbstractArrayRead___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Array___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 4 /* 48: Array < SimpleCollection: superclass init_table position */},
  {(bigint) standard___collection___array___Array___add},
  {(bigint) standard___collection___abstract_collection___SimpleCollection___add_all},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 8 /* 55: Array < ArrayCapable: superclass init_table position */},
  {(bigint) standard___collection___array___ArrayCapable___calloc_array},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___string___Collection___join},
  {(bigint) standard___collection___array___Collection___to_a},
  {(bigint) 6 /* 64: Array < Collection: superclass init_table position */},
  {(bigint) standard___collection___array___AbstractArrayRead___iterator},
  {(bigint) standard___collection___array___Array___iterate},
  {(bigint) standard___collection___array___AbstractArrayRead___is_empty},
  {(bigint) standard___collection___array___AbstractArrayRead___length},
  {(bigint) standard___collection___array___AbstractArrayRead___has},
  {(bigint) standard___collection___array___AbstractArrayRead___has_only},
  {(bigint) standard___collection___array___AbstractArrayRead___count},
  {(bigint) standard___collection___abstract_collection___SequenceRead___first},
  {(bigint) standard___math___Collection___rand},
  {(bigint) 3 /* 74: Array < SequenceRead: superclass init_table position */},
  {(bigint) standard___collection___array___Array_____bra},
  {(bigint) standard___collection___abstract_collection___SequenceRead___last},
  {(bigint) standard___collection___array___AbstractArrayRead___index_of},
  {(bigint) 5 /* 78: Array < RemovableCollection: superclass init_table position */},
  {(bigint) standard___collection___array___AbstractArray___clear},
  {(bigint) standard___collection___array___AbstractArray___remove},
  {(bigint) standard___collection___array___AbstractArray___remove_all},
  {(bigint) 1 /* 82: Array < AbstractArrayRead: superclass init_table position */},
  {(bigint) standard___collection___array___AbstractArrayRead___last_index_of},
  {(bigint) standard___collection___array___AbstractArrayRead___index_of_from},
  {(bigint) standard___collection___array___AbstractArrayRead___last_index_of_from},
  {(bigint) standard___collection___array___AbstractArrayRead___reversed},
  {(bigint) standard___collection___array___AbstractArrayRead___copy_to},
  {(bigint) standard___collection___array___AbstractArrayRead___init},
  {(bigint) 2 /* 89: Array < Sequence: superclass init_table position */},
  {(bigint) standard___collection___abstract_collection___Sequence___first__eq},
  {(bigint) standard___collection___abstract_collection___Sequence___last__eq},
  {(bigint) standard___collection___array___AbstractArray___push},
  {(bigint) standard___collection___abstract_collection___Sequence___append},
  {(bigint) standard___collection___array___AbstractArray___pop},
  {(bigint) standard___collection___array___AbstractArray___unshift},
  {(bigint) standard___collection___array___AbstractArray___shift},
  {(bigint) standard___collection___array___Array_____braeq},
  {(bigint) standard___collection___array___AbstractArray___remove_at},
  {(bigint) 9 /* 99: Array < Array: superclass init_table position */},
  {(bigint) standard___collection___array___Array___init},
  {(bigint) standard___collection___array___Array___with_items},
  {(bigint) standard___collection___array___Array___with_capacity},
  {(bigint) standard___collection___array___Array___filled_with},
  {(bigint) standard___collection___array___Array___with_native},
  {(bigint) standard___collection___array___Array___intern_items},
  {(bigint) standard___collection___array___Array___sort},
  {(bigint) standard___collection___array___Array___sub_sort},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 0 /* 111: Array < AbstractArray: superclass init_table position */},
  {(bigint) standard___collection___array___Array___enlarge},
  {(bigint) standard___collection___array___AbstractArray___insert},
  {(bigint) standard___collection___array___AbstractArray___swap_at},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Array::_length */
/* 3: Attribute Array::_items */
/* 4: Attribute Array::_capacity */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___array___Array[] = "init var of Array";
void INIT_ATTRIBUTES__standard___collection___array___Array(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___array___Array;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/array.nit:364 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___collection___array___Array____items(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/array.nit:372 */
  REGB0 = TAG_Int(0);
  ATTR_standard___collection___array___Array____capacity(fra.me.REG[0]) = REGB0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/array.nit:24 */
  REGB0 = TAG_Int(0);
  ATTR_standard___collection___array___AbstractArrayRead____length(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___array___Array(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___array___Array;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___array___Array[] = "check new Array";
void CHECKNEW_standard___collection___array___Array(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___array___Array;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___array___Array____capacity(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_capacity", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___collection___array___AbstractArrayRead____length(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_length", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_Array_standard___collection___array___Array___with_capacity[] = "new Array array::Array::with_capacity";
val_t NEW_Array_standard___collection___array___Array___with_capacity(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  int init_table[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 332;
  fra.me.meth = LOCATE_NEW_Array_standard___collection___array___Array___with_capacity;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  REGB0 = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/array.nit:332 */
  fra.me.REG[0] = NEW_standard___collection___array___Array();
  INIT_ATTRIBUTES__standard___collection___array___Array(fra.me.REG[0]);
  standard___collection___array___Array___with_capacity(fra.me.REG[0], REGB0, init_table);
  CHECKNEW_standard___collection___array___Array(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
static const char LOCATE_NEW_Array_standard___collection___array___Array___init[] = "new Array array::Array::init";
val_t NEW_Array_standard___collection___array___Array___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 317;
  fra.me.meth = LOCATE_NEW_Array_standard___collection___array___Array___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/array.nit:317 */
  fra.me.REG[0] = NEW_standard___collection___array___Array();
  INIT_ATTRIBUTES__standard___collection___array___Array(fra.me.REG[0]);
  standard___collection___array___Array___init(fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___array___Array(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
static const char LOCATE_NEW_Array_standard___collection___array___Array___filled_with[] = "new Array array::Array::filled_with";
val_t NEW_Array_standard___collection___array___Array___filled_with(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t REGB0;
  val_t tmp;
  int init_table[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 341;
  fra.me.meth = LOCATE_NEW_Array_standard___collection___array___Array___filled_with;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = p1;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/array.nit:341 */
  fra.me.REG[1] = NEW_standard___collection___array___Array();
  INIT_ATTRIBUTES__standard___collection___array___Array(fra.me.REG[1]);
  standard___collection___array___Array___filled_with(fra.me.REG[1], fra.me.REG[0], REGB0, init_table);
  CHECKNEW_standard___collection___array___Array(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
static const char LOCATE_NEW_Array_standard___collection___array___Array___with_items[] = "new Array array::Array::with_items";
val_t NEW_Array_standard___collection___array___Array___with_items(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 324;
  fra.me.meth = LOCATE_NEW_Array_standard___collection___array___Array___with_items;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/array.nit:324 */
  fra.me.REG[1] = NEW_standard___collection___array___Array();
  INIT_ATTRIBUTES__standard___collection___array___Array(fra.me.REG[1]);
  standard___collection___array___Array___with_items(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___array___Array(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
static const char LOCATE_NEW_Array_standard___collection___array___Array___with_native[] = "new Array array::Array::with_native";
val_t NEW_Array_standard___collection___array___Array___with_native(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t REGB0;
  val_t tmp;
  int init_table[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 355;
  fra.me.meth = LOCATE_NEW_Array_standard___collection___array___Array___with_native;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = p1;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/array.nit:355 */
  fra.me.REG[1] = NEW_standard___collection___array___Array();
  INIT_ATTRIBUTES__standard___collection___array___Array(fra.me.REG[1]);
  standard___collection___array___Array___with_native(fra.me.REG[1], fra.me.REG[0], REGB0, init_table);
  CHECKNEW_standard___collection___array___Array(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___collection___array___ArrayIterator[55] = {
  {(bigint) 239 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "ArrayIterator" /* 2: Class Name */},
  {(bigint) 3 /* 3: ArrayIterator < Object: superclass typecheck marker */},
  {(bigint) 39 /* 4: ArrayIterator < Iterator: superclass typecheck marker */},
  {(bigint) 111 /* 5: ArrayIterator < IndexedIterator: superclass typecheck marker */},
  {(bigint) 239 /* 6: ArrayIterator < ArrayIterator: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 2 /* 17: ArrayIterator < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) standard___collection___array___Iterator___to_a},
  {(bigint) 1 /* 47: ArrayIterator < Iterator: superclass init_table position */},
  {(bigint) standard___collection___array___ArrayIterator___item},
  {(bigint) standard___collection___array___ArrayIterator___next},
  {(bigint) standard___collection___array___ArrayIterator___is_ok},
  {(bigint) 0 /* 51: ArrayIterator < IndexedIterator: superclass init_table position */},
  {(bigint) standard___collection___array___ArrayIterator___index},
  {(bigint) 3 /* 53: ArrayIterator < ArrayIterator: superclass init_table position */},
  {(bigint) standard___collection___array___ArrayIterator___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute ArrayIterator::_index */
/* 3: Attribute ArrayIterator::_array */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___array___ArrayIterator[] = "init var of ArrayIterator";
void INIT_ATTRIBUTES__standard___collection___array___ArrayIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___array___ArrayIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/array.nit:445 */
  REGB0 = TAG_Int(0);
  ATTR_standard___collection___array___ArrayIterator____index(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___array___ArrayIterator(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___array___ArrayIterator;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___array___ArrayIterator[] = "check new ArrayIterator";
void CHECKNEW_standard___collection___array___ArrayIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___array___ArrayIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___array___ArrayIterator____index(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_index", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___collection___array___ArrayIterator____array(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_array", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_ArrayIterator_standard___collection___array___ArrayIterator___init[] = "new ArrayIterator array::ArrayIterator::init";
val_t NEW_ArrayIterator_standard___collection___array___ArrayIterator___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[4] = {0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 439;
  fra.me.meth = LOCATE_NEW_ArrayIterator_standard___collection___array___ArrayIterator___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/array.nit:439 */
  fra.me.REG[1] = NEW_standard___collection___array___ArrayIterator();
  INIT_ATTRIBUTES__standard___collection___array___ArrayIterator(fra.me.REG[1]);
  standard___collection___array___ArrayIterator___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___array___ArrayIterator(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___collection___array___ArraySet[87] = {
  {(bigint) 299 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "ArraySet" /* 2: Class Name */},
  {(bigint) 3 /* 3: ArraySet < Object: superclass typecheck marker */},
  {(bigint) 255 /* 4: ArraySet < Set: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 59 /* 6: ArraySet < Collection: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 79 /* 8: ArraySet < RemovableCollection: superclass typecheck marker */},
  {(bigint) 175 /* 9: ArraySet < SimpleCollection: superclass typecheck marker */},
  {(bigint) 299 /* 10: ArraySet < ArraySet: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 4 /* 17: ArraySet < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Collection___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 0 /* 46: ArraySet < Set: superclass init_table position */},
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 48: ArraySet < SimpleCollection: superclass init_table position */},
  {(bigint) standard___collection___array___ArraySet___add},
  {(bigint) standard___collection___abstract_collection___SimpleCollection___add_all},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___string___Collection___join},
  {(bigint) standard___collection___array___Collection___to_a},
  {(bigint) 3 /* 64: ArraySet < Collection: superclass init_table position */},
  {(bigint) standard___collection___array___ArraySet___iterator},
  {(bigint) standard___collection___abstract_collection___Collection___iterate},
  {(bigint) standard___collection___array___ArraySet___is_empty},
  {(bigint) standard___collection___array___ArraySet___length},
  {(bigint) standard___collection___array___ArraySet___has},
  {(bigint) standard___collection___abstract_collection___Set___has_only},
  {(bigint) standard___collection___abstract_collection___Set___count},
  {(bigint) standard___collection___array___ArraySet___first},
  {(bigint) standard___math___Collection___rand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 2 /* 78: ArraySet < RemovableCollection: superclass init_table position */},
  {(bigint) standard___collection___array___ArraySet___clear},
  {(bigint) standard___collection___array___ArraySet___remove},
  {(bigint) standard___collection___array___ArraySet___remove_all},
  {(bigint) 5 /* 82: ArraySet < ArraySet: superclass init_table position */},
  {(bigint) standard___collection___array___ArraySet___enlarge},
  {(bigint) standard___collection___array___ArraySet___remove_at},
  {(bigint) standard___collection___array___ArraySet___init},
  {(bigint) standard___collection___array___ArraySet___with_capacity},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute ArraySet::_array */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___array___ArraySet[] = "init var of ArraySet";
void INIT_ATTRIBUTES__standard___collection___array___ArraySet(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___array___ArraySet;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___array___ArraySet(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___array___ArraySet;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___array___ArraySet[] = "check new ArraySet";
void CHECKNEW_standard___collection___array___ArraySet(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___array___ArraySet;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___array___ArraySet____array(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_array", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_ArraySet_standard___collection___array___ArraySet___init[] = "new ArraySet array::ArraySet::init";
val_t NEW_ArraySet_standard___collection___array___ArraySet___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[6] = {0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 493;
  fra.me.meth = LOCATE_NEW_ArraySet_standard___collection___array___ArraySet___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/array.nit:493 */
  fra.me.REG[0] = NEW_standard___collection___array___ArraySet();
  INIT_ATTRIBUTES__standard___collection___array___ArraySet(fra.me.REG[0]);
  standard___collection___array___ArraySet___init(fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___array___ArraySet(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
static const char LOCATE_NEW_ArraySet_standard___collection___array___ArraySet___with_capacity[] = "new ArraySet array::ArraySet::with_capacity";
val_t NEW_ArraySet_standard___collection___array___ArraySet___with_capacity(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  int init_table[6] = {0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 496;
  fra.me.meth = LOCATE_NEW_ArraySet_standard___collection___array___ArraySet___with_capacity;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  REGB0 = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/array.nit:496 */
  fra.me.REG[0] = NEW_standard___collection___array___ArraySet();
  INIT_ATTRIBUTES__standard___collection___array___ArraySet(fra.me.REG[0]);
  standard___collection___array___ArraySet___with_capacity(fra.me.REG[0], REGB0, init_table);
  CHECKNEW_standard___collection___array___ArraySet(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_standard___collection___array___ArraySetIterator[53] = {
  {(bigint) 171 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "ArraySetIterator" /* 2: Class Name */},
  {(bigint) 3 /* 3: ArraySetIterator < Object: superclass typecheck marker */},
  {(bigint) 39 /* 4: ArraySetIterator < Iterator: superclass typecheck marker */},
  {(bigint) 171 /* 5: ArraySetIterator < ArraySetIterator: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 1 /* 17: ArraySetIterator < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) standard___collection___array___Iterator___to_a},
  {(bigint) 0 /* 47: ArraySetIterator < Iterator: superclass init_table position */},
  {(bigint) standard___collection___array___ArraySetIterator___item},
  {(bigint) standard___collection___array___ArraySetIterator___next},
  {(bigint) standard___collection___array___ArraySetIterator___is_ok},
  {(bigint) 2 /* 51: ArraySetIterator < ArraySetIterator: superclass init_table position */},
  {(bigint) standard___collection___array___ArraySetIterator___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute ArraySetIterator::_iter */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___array___ArraySetIterator[] = "init var of ArraySetIterator";
void INIT_ATTRIBUTES__standard___collection___array___ArraySetIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___array___ArraySetIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___array___ArraySetIterator(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___array___ArraySetIterator;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___array___ArraySetIterator[] = "check new ArraySetIterator";
void CHECKNEW_standard___collection___array___ArraySetIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___array___ArraySetIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___array___ArraySetIterator____iter(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_iter", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_ArraySetIterator_standard___collection___array___ArraySetIterator___init[] = "new ArraySetIterator array::ArraySetIterator::init";
val_t NEW_ArraySetIterator_standard___collection___array___ArraySetIterator___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 510;
  fra.me.meth = LOCATE_NEW_ArraySetIterator_standard___collection___array___ArraySetIterator___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/array.nit:510 */
  fra.me.REG[1] = NEW_standard___collection___array___ArraySetIterator();
  INIT_ATTRIBUTES__standard___collection___array___ArraySetIterator(fra.me.REG[1]);
  standard___collection___array___ArraySetIterator___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___array___ArraySetIterator(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___collection___array___ArrayMap[71] = {
  {(bigint) 275 /* 0: Identity */},
  {(bigint) 6 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "ArrayMap" /* 2: Class Name */},
  {(bigint) 3 /* 3: ArrayMap < Object: superclass typecheck marker */},
  {(bigint) 31 /* 4: ArrayMap < MapRead: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 103 /* 6: ArrayMap < Map: superclass typecheck marker */},
  {(bigint) 223 /* 7: ArrayMap < CoupleMap: superclass typecheck marker */},
  {(bigint) 275 /* 8: ArrayMap < ArrayMap: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 3 /* 17: ArrayMap < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 2 /* 46: ArrayMap < MapRead: superclass init_table position */},
  {(bigint) standard___collection___array___ArrayMap_____bra},
  {(bigint) standard___collection___abstract_collection___MapRead___has_key},
  {(bigint) standard___collection___array___ArrayMap___iterator},
  {(bigint) standard___collection___abstract_collection___MapRead___iterate},
  {(bigint) standard___collection___array___ArrayMap___values},
  {(bigint) standard___collection___array___ArrayMap___keys},
  {(bigint) standard___collection___array___ArrayMap___is_empty},
  {(bigint) standard___collection___array___ArrayMap___length},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___string___Map___join},
  {(bigint) 1 /* 58: ArrayMap < Map: superclass init_table position */},
  {(bigint) standard___collection___array___ArrayMap_____braeq},
  {(bigint) standard___collection___abstract_collection___Map___recover_with},
  {(bigint) standard___collection___array___ArrayMap___clear},
  {(bigint) 0 /* 62: ArrayMap < CoupleMap: superclass init_table position */},
  {(bigint) standard___collection___array___ArrayMap___couple_at},
  {(bigint) 4 /* 64: ArrayMap < ArrayMap: superclass init_table position */},
  {(bigint) standard___collection___array___ArrayMap___keys__eq},
  {(bigint) standard___collection___array___ArrayMap___values__eq},
  {(bigint) standard___collection___array___ArrayMap___enlarge},
  {(bigint) standard___collection___array___ArrayMap___remove_at_index},
  {(bigint) standard___collection___array___ArrayMap___index},
  {(bigint) standard___collection___array___ArrayMap___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute ArrayMap::@keys */
/* 3: Attribute ArrayMap::@values */
/* 4: Attribute ArrayMap::_items */
/* 5: Attribute ArrayMap::_last_index */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___array___ArrayMap[] = "init var of ArrayMap";
void INIT_ATTRIBUTES__standard___collection___array___ArrayMap(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___array___ArrayMap;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/array.nit:542 */
  fra.me.REG[1] = fra.me.REG[0];
  fra.me.REG[1] = NEW_ArrayMapKeys_standard___collection___array___ArrayMapKeys___init(fra.me.REG[1]);
  ATTR_standard___collection___array___ArrayMap_____atkeys(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/array.nit:543 */
  fra.me.REG[1] = fra.me.REG[0];
  fra.me.REG[1] = NEW_ArrayMapValues_standard___collection___array___ArrayMapValues___init(fra.me.REG[1]);
  ATTR_standard___collection___array___ArrayMap_____atvalues(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/array.nit:578 */
  REGB0 = TAG_Int(0);
  ATTR_standard___collection___array___ArrayMap____last_index(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___array___ArrayMap(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 6);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___array___ArrayMap;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___array___ArrayMap[] = "check new ArrayMap";
void CHECKNEW_standard___collection___array___ArrayMap(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___array___ArrayMap;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___array___ArrayMap_____atkeys(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@keys", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___collection___array___ArrayMap_____atvalues(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@values", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___collection___array___ArrayMap____items(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_items", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___collection___array___ArrayMap____last_index(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_last_index", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_ArrayMap_standard___collection___array___ArrayMap___init[] = "new ArrayMap array::ArrayMap::init";
val_t NEW_ArrayMap_standard___collection___array___ArrayMap___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[5] = {0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 598;
  fra.me.meth = LOCATE_NEW_ArrayMap_standard___collection___array___ArrayMap___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/array.nit:598 */
  fra.me.REG[0] = NEW_standard___collection___array___ArrayMap();
  INIT_ATTRIBUTES__standard___collection___array___ArrayMap(fra.me.REG[0]);
  standard___collection___array___ArrayMap___init(fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___array___ArrayMap(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_standard___collection___array___ArrayMapKeys[86] = {
  {(bigint) 235 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "ArrayMapKeys" /* 2: Class Name */},
  {(bigint) 3 /* 3: ArrayMapKeys < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 59 /* 6: ArrayMapKeys < Collection: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 79 /* 8: ArrayMapKeys < RemovableCollection: superclass typecheck marker */},
  {(bigint) 235 /* 9: ArrayMapKeys < ArrayMapKeys: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 2 /* 17: ArrayMapKeys < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Collection___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___string___Collection___join},
  {(bigint) standard___collection___array___Collection___to_a},
  {(bigint) 1 /* 64: ArrayMapKeys < Collection: superclass init_table position */},
  {(bigint) standard___collection___array___ArrayMapKeys___iterator},
  {(bigint) standard___collection___abstract_collection___Collection___iterate},
  {(bigint) standard___collection___array___ArrayMapKeys___is_empty},
  {(bigint) standard___collection___array___ArrayMapKeys___length},
  {(bigint) standard___collection___array___ArrayMapKeys___has},
  {(bigint) standard___collection___array___ArrayMapKeys___has_only},
  {(bigint) standard___collection___array___ArrayMapKeys___count},
  {(bigint) standard___collection___array___ArrayMapKeys___first},
  {(bigint) standard___math___Collection___rand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 0 /* 78: ArrayMapKeys < RemovableCollection: superclass init_table position */},
  {(bigint) standard___collection___array___ArrayMapKeys___clear},
  {(bigint) standard___collection___array___ArrayMapKeys___remove},
  {(bigint) standard___collection___array___ArrayMapKeys___remove_all},
  {(bigint) 3 /* 82: ArrayMapKeys < ArrayMapKeys: superclass init_table position */},
  {(bigint) standard___collection___array___ArrayMapKeys___map},
  {(bigint) standard___collection___array___ArrayMapKeys___map__eq},
  {(bigint) standard___collection___array___ArrayMapKeys___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute ArrayMapKeys::@map */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___array___ArrayMapKeys[] = "init var of ArrayMapKeys";
void INIT_ATTRIBUTES__standard___collection___array___ArrayMapKeys(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___array___ArrayMapKeys;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___array___ArrayMapKeys(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___array___ArrayMapKeys;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___array___ArrayMapKeys[] = "check new ArrayMapKeys";
void CHECKNEW_standard___collection___array___ArrayMapKeys(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___array___ArrayMapKeys;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___array___ArrayMapKeys_____atmap(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@map", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_ArrayMapKeys_standard___collection___array___ArrayMapKeys___init[] = "new ArrayMapKeys array::ArrayMapKeys::init";
val_t NEW_ArrayMapKeys_standard___collection___array___ArrayMapKeys___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[4] = {0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_NEW_ArrayMapKeys_standard___collection___array___ArrayMapKeys___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = NEW_standard___collection___array___ArrayMapKeys();
  INIT_ATTRIBUTES__standard___collection___array___ArrayMapKeys(fra.me.REG[1]);
  standard___collection___array___ArrayMapKeys___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___array___ArrayMapKeys(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___collection___array___ArrayMapValues[86] = {
  {(bigint) 231 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "ArrayMapValues" /* 2: Class Name */},
  {(bigint) 3 /* 3: ArrayMapValues < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 59 /* 6: ArrayMapValues < Collection: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 79 /* 8: ArrayMapValues < RemovableCollection: superclass typecheck marker */},
  {(bigint) 231 /* 9: ArrayMapValues < ArrayMapValues: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 2 /* 17: ArrayMapValues < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Collection___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___string___Collection___join},
  {(bigint) standard___collection___array___Collection___to_a},
  {(bigint) 1 /* 64: ArrayMapValues < Collection: superclass init_table position */},
  {(bigint) standard___collection___array___ArrayMapValues___iterator},
  {(bigint) standard___collection___abstract_collection___Collection___iterate},
  {(bigint) standard___collection___array___ArrayMapValues___is_empty},
  {(bigint) standard___collection___array___ArrayMapValues___length},
  {(bigint) standard___collection___array___ArrayMapValues___has},
  {(bigint) standard___collection___array___ArrayMapValues___has_only},
  {(bigint) standard___collection___array___ArrayMapValues___count},
  {(bigint) standard___collection___array___ArrayMapValues___first},
  {(bigint) standard___math___Collection___rand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 0 /* 78: ArrayMapValues < RemovableCollection: superclass init_table position */},
  {(bigint) standard___collection___array___ArrayMapValues___clear},
  {(bigint) standard___collection___array___ArrayMapValues___remove},
  {(bigint) standard___collection___array___ArrayMapValues___remove_all},
  {(bigint) 3 /* 82: ArrayMapValues < ArrayMapValues: superclass init_table position */},
  {(bigint) standard___collection___array___ArrayMapValues___map},
  {(bigint) standard___collection___array___ArrayMapValues___map__eq},
  {(bigint) standard___collection___array___ArrayMapValues___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute ArrayMapValues::@map */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___array___ArrayMapValues[] = "init var of ArrayMapValues";
void INIT_ATTRIBUTES__standard___collection___array___ArrayMapValues(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___array___ArrayMapValues;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___array___ArrayMapValues(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___array___ArrayMapValues;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___array___ArrayMapValues[] = "check new ArrayMapValues";
void CHECKNEW_standard___collection___array___ArrayMapValues(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___array___ArrayMapValues;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___array___ArrayMapValues_____atmap(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@map", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_ArrayMapValues_standard___collection___array___ArrayMapValues___init[] = "new ArrayMapValues array::ArrayMapValues::init";
val_t NEW_ArrayMapValues_standard___collection___array___ArrayMapValues___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[4] = {0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_NEW_ArrayMapValues_standard___collection___array___ArrayMapValues___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = NEW_standard___collection___array___ArrayMapValues();
  INIT_ATTRIBUTES__standard___collection___array___ArrayMapValues(fra.me.REG[1]);
  standard___collection___array___ArrayMapValues___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___array___ArrayMapValues(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___collection___array___NativeArray[50] = {
  {(bigint) 23 /* 0: Identity */},
  {(bigint) -1 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "NativeArray" /* 2: Class Name */},
  {(bigint) 3 /* 3: NativeArray < Object: superclass typecheck marker */},
  {(bigint) 23 /* 4: NativeArray < NativeArray: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 0 /* 17: NativeArray < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 1 /* 46: NativeArray < NativeArray: superclass init_table position */},
  {(bigint) standard___collection___array___NativeArray_____bra},
  {(bigint) standard___collection___array___NativeArray_____braeq},
  {(bigint) standard___collection___array___NativeArray___copy_to},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
val_t NEW_NativeArray(size_t length, size_t size) {
  Nit_NativeArray array;
  array = (Nit_NativeArray)alloc(sizeof(struct Nit_NativeArray) + ((length - 1) * size));
  array->vft = (classtable_elt_t*)VFT_standard___collection___array___NativeArray;
  array->object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  array->size = length;
  return OBJ2VAL(array);
}
const classtable_elt_t VFT_standard___collection___sorter___ComparableSorter[54] = {
  {(bigint) 163 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "ComparableSorter" /* 2: Class Name */},
  {(bigint) 3 /* 3: ComparableSorter < Object: superclass typecheck marker */},
  {(bigint) 71 /* 4: ComparableSorter < AbstractSorter: superclass typecheck marker */},
  {(bigint) 163 /* 5: ComparableSorter < ComparableSorter: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 1 /* 17: ComparableSorter < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 0 /* 46: ComparableSorter < AbstractSorter: superclass init_table position */},
  {(bigint) standard___collection___sorter___ComparableSorter___compare},
  {(bigint) standard___collection___sorter___AbstractSorter___sort},
  {(bigint) standard___collection___sorter___AbstractSorter___sub_sort},
  {(bigint) standard___collection___sorter___AbstractSorter___quick_sort},
  {(bigint) standard___collection___sorter___AbstractSorter___bubble_sort},
  {(bigint) 2 /* 52: ComparableSorter < ComparableSorter: superclass init_table position */},
  {(bigint) standard___collection___sorter___ComparableSorter___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___sorter___ComparableSorter[] = "init var of ComparableSorter";
void INIT_ATTRIBUTES__standard___collection___sorter___ComparableSorter(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___sorter___ComparableSorter;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___sorter___ComparableSorter(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 2);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___sorter___ComparableSorter;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___sorter___ComparableSorter[] = "check new ComparableSorter";
void CHECKNEW_standard___collection___sorter___ComparableSorter(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___sorter___ComparableSorter;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_ComparableSorter_standard___collection___sorter___ComparableSorter___init[] = "new ComparableSorter sorter::ComparableSorter::init";
val_t NEW_ComparableSorter_standard___collection___sorter___ComparableSorter___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 96;
  fra.me.meth = LOCATE_NEW_ComparableSorter_standard___collection___sorter___ComparableSorter___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/sorter.nit:96 */
  fra.me.REG[0] = NEW_standard___collection___sorter___ComparableSorter();
  INIT_ATTRIBUTES__standard___collection___sorter___ComparableSorter(fra.me.REG[0]);
  standard___collection___sorter___ComparableSorter___init(fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___sorter___ComparableSorter(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_standard___collection___hash_collection___HashMap[92] = {
  {(bigint) 211 /* 0: Identity */},
  {(bigint) 11 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "HashMap" /* 2: Class Name */},
  {(bigint) 3 /* 3: HashMap < Object: superclass typecheck marker */},
  {(bigint) 31 /* 4: HashMap < MapRead: superclass typecheck marker */},
  {(bigint) 67 /* 5: HashMap < ArrayCapable: superclass typecheck marker */},
  {(bigint) 103 /* 6: HashMap < Map: superclass typecheck marker */},
  {(bigint) 135 /* 7: HashMap < HashCollection: superclass typecheck marker */},
  {(bigint) 211 /* 8: HashMap < HashMap: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 2 /* 17: HashMap < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 1 /* 46: HashMap < MapRead: superclass init_table position */},
  {(bigint) standard___collection___hash_collection___HashMap_____bra},
  {(bigint) standard___collection___abstract_collection___MapRead___has_key},
  {(bigint) standard___collection___hash_collection___HashMap___iterator},
  {(bigint) standard___collection___hash_collection___HashMap___iterate},
  {(bigint) standard___collection___hash_collection___HashMap___values},
  {(bigint) standard___collection___hash_collection___HashMap___keys},
  {(bigint) standard___collection___hash_collection___HashMap___is_empty},
  {(bigint) standard___collection___hash_collection___HashMap___length},
  {(bigint) 4 /* 55: HashMap < ArrayCapable: superclass init_table position */},
  {(bigint) standard___collection___array___ArrayCapable___calloc_array},
  {(bigint) standard___string___Map___join},
  {(bigint) 0 /* 58: HashMap < Map: superclass init_table position */},
  {(bigint) standard___collection___hash_collection___HashMap_____braeq},
  {(bigint) standard___collection___abstract_collection___Map___recover_with},
  {(bigint) standard___collection___hash_collection___HashMap___clear},
  {(bigint) 5 /* 62: HashMap < HashMap: superclass init_table position */},
  {(bigint) standard___collection___hash_collection___HashMap___init},
  {(bigint) standard___collection___hash_collection___HashMap___keys__eq},
  {(bigint) standard___collection___hash_collection___HashMap___values__eq},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 3 /* 82: HashMap < HashCollection: superclass init_table position */},
  {(bigint) standard___collection___hash_collection___HashCollection___first_item},
  {(bigint) standard___collection___hash_collection___HashCollection___index_at},
  {(bigint) standard___collection___hash_collection___HashCollection___node_at},
  {(bigint) standard___collection___hash_collection___HashCollection___node_at_idx},
  {(bigint) standard___collection___hash_collection___HashCollection___store},
  {(bigint) standard___collection___hash_collection___HashCollection___remove_node},
  {(bigint) standard___collection___hash_collection___HashCollection___raz},
  {(bigint) standard___collection___hash_collection___HashCollection___enlarge},
  {(bigint) standard___collection___hash_collection___HashCollection___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute HashMap::_array */
/* 3: Attribute HashMap::_capacity */
/* 4: Attribute HashMap::_length */
/* 5: Attribute HashMap::_first_item */
/* 6: Attribute HashMap::_last_item */
/* 7: Attribute HashMap::_last_accessed_key */
/* 8: Attribute HashMap::_last_accessed_node */
/* 9: Attribute HashMap::@keys */
/* 10: Attribute HashMap::@values */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___hash_collection___HashMap[] = "init var of HashMap";
void INIT_ATTRIBUTES__standard___collection___hash_collection___HashMap(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___hash_collection___HashMap;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:255 */
  fra.me.REG[1] = fra.me.REG[0];
  fra.me.REG[1] = NEW_HashMapKeys_standard___collection___hash_collection___HashMapKeys___init(fra.me.REG[1]);
  ATTR_standard___collection___hash_collection___HashMap_____atkeys(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:256 */
  fra.me.REG[1] = fra.me.REG[0];
  fra.me.REG[1] = NEW_HashMapValues_standard___collection___hash_collection___HashMapValues___init(fra.me.REG[1]);
  ATTR_standard___collection___hash_collection___HashMap_____atvalues(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:23 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___collection___hash_collection___HashCollection____array(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:24 */
  REGB0 = TAG_Int(0);
  ATTR_standard___collection___hash_collection___HashCollection____capacity(fra.me.REG[0]) = REGB0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:25 */
  REGB0 = TAG_Int(0);
  ATTR_standard___collection___hash_collection___HashCollection____length(fra.me.REG[0]) = REGB0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:27 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___collection___hash_collection___HashCollection____first_item(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:28 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___collection___hash_collection___HashCollection____last_item(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:30 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___collection___hash_collection___HashCollection____last_accessed_key(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:33 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___collection___hash_collection___HashCollection____last_accessed_node(fra.me.REG[0]) = fra.me.REG[1];
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___hash_collection___HashMap(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 11);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___hash_collection___HashMap;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___hash_collection___HashMap[] = "check new HashMap";
void CHECKNEW_standard___collection___hash_collection___HashMap(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___hash_collection___HashMap;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___hash_collection___HashMap_____atkeys(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@keys", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___collection___hash_collection___HashMap_____atvalues(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@values", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___collection___hash_collection___HashCollection____capacity(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_capacity", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___collection___hash_collection___HashCollection____length(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_length", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_HashMap_standard___collection___hash_collection___HashMap___init[] = "new HashMap hash_collection::HashMap::init";
val_t NEW_HashMap_standard___collection___hash_collection___HashMap___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[6] = {0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 248;
  fra.me.meth = LOCATE_NEW_HashMap_standard___collection___hash_collection___HashMap___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:248 */
  fra.me.REG[0] = NEW_standard___collection___hash_collection___HashMap();
  INIT_ATTRIBUTES__standard___collection___hash_collection___HashMap(fra.me.REG[0]);
  standard___collection___hash_collection___HashMap___init(fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___hash_collection___HashMap(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_standard___collection___hash_collection___HashMapKeys[86] = {
  {(bigint) 207 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "HashMapKeys" /* 2: Class Name */},
  {(bigint) 3 /* 3: HashMapKeys < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 59 /* 6: HashMapKeys < Collection: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 79 /* 8: HashMapKeys < RemovableCollection: superclass typecheck marker */},
  {(bigint) 207 /* 9: HashMapKeys < HashMapKeys: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 2 /* 17: HashMapKeys < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Collection___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___string___Collection___join},
  {(bigint) standard___collection___array___Collection___to_a},
  {(bigint) 1 /* 64: HashMapKeys < Collection: superclass init_table position */},
  {(bigint) standard___collection___hash_collection___HashMapKeys___iterator},
  {(bigint) standard___collection___abstract_collection___Collection___iterate},
  {(bigint) standard___collection___hash_collection___HashMapKeys___is_empty},
  {(bigint) standard___collection___hash_collection___HashMapKeys___length},
  {(bigint) standard___collection___hash_collection___HashMapKeys___has},
  {(bigint) standard___collection___hash_collection___HashMapKeys___has_only},
  {(bigint) standard___collection___hash_collection___HashMapKeys___count},
  {(bigint) standard___collection___hash_collection___HashMapKeys___first},
  {(bigint) standard___math___Collection___rand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 0 /* 78: HashMapKeys < RemovableCollection: superclass init_table position */},
  {(bigint) standard___collection___hash_collection___HashMapKeys___clear},
  {(bigint) standard___collection___hash_collection___HashMapKeys___remove},
  {(bigint) standard___collection___hash_collection___HashMapKeys___remove_all},
  {(bigint) 3 /* 82: HashMapKeys < HashMapKeys: superclass init_table position */},
  {(bigint) standard___collection___hash_collection___HashMapKeys___map},
  {(bigint) standard___collection___hash_collection___HashMapKeys___map__eq},
  {(bigint) standard___collection___hash_collection___HashMapKeys___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute HashMapKeys::@map */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapKeys[] = "init var of HashMapKeys";
void INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapKeys(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapKeys;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___hash_collection___HashMapKeys(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___hash_collection___HashMapKeys;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___hash_collection___HashMapKeys[] = "check new HashMapKeys";
void CHECKNEW_standard___collection___hash_collection___HashMapKeys(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___hash_collection___HashMapKeys;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___hash_collection___HashMapKeys_____atmap(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@map", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_HashMapKeys_standard___collection___hash_collection___HashMapKeys___init[] = "new HashMapKeys hash_collection::HashMapKeys::init";
val_t NEW_HashMapKeys_standard___collection___hash_collection___HashMapKeys___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[4] = {0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_NEW_HashMapKeys_standard___collection___hash_collection___HashMapKeys___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = NEW_standard___collection___hash_collection___HashMapKeys();
  INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapKeys(fra.me.REG[1]);
  standard___collection___hash_collection___HashMapKeys___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___hash_collection___HashMapKeys(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___collection___hash_collection___HashMapValues[86] = {
  {(bigint) 203 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "HashMapValues" /* 2: Class Name */},
  {(bigint) 3 /* 3: HashMapValues < Object: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 59 /* 6: HashMapValues < Collection: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 79 /* 8: HashMapValues < RemovableCollection: superclass typecheck marker */},
  {(bigint) 203 /* 9: HashMapValues < HashMapValues: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 2 /* 17: HashMapValues < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Collection___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___string___Collection___join},
  {(bigint) standard___collection___array___Collection___to_a},
  {(bigint) 1 /* 64: HashMapValues < Collection: superclass init_table position */},
  {(bigint) standard___collection___hash_collection___HashMapValues___iterator},
  {(bigint) standard___collection___abstract_collection___Collection___iterate},
  {(bigint) standard___collection___hash_collection___HashMapValues___is_empty},
  {(bigint) standard___collection___hash_collection___HashMapValues___length},
  {(bigint) standard___collection___hash_collection___HashMapValues___has},
  {(bigint) standard___collection___hash_collection___HashMapValues___has_only},
  {(bigint) standard___collection___hash_collection___HashMapValues___count},
  {(bigint) standard___collection___hash_collection___HashMapValues___first},
  {(bigint) standard___math___Collection___rand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 0 /* 78: HashMapValues < RemovableCollection: superclass init_table position */},
  {(bigint) standard___collection___hash_collection___HashMapValues___clear},
  {(bigint) standard___collection___hash_collection___HashMapValues___remove},
  {(bigint) standard___collection___hash_collection___HashMapValues___remove_all},
  {(bigint) 3 /* 82: HashMapValues < HashMapValues: superclass init_table position */},
  {(bigint) standard___collection___hash_collection___HashMapValues___map},
  {(bigint) standard___collection___hash_collection___HashMapValues___map__eq},
  {(bigint) standard___collection___hash_collection___HashMapValues___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute HashMapValues::@map */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapValues[] = "init var of HashMapValues";
void INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapValues(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapValues;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___hash_collection___HashMapValues(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___hash_collection___HashMapValues;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___hash_collection___HashMapValues[] = "check new HashMapValues";
void CHECKNEW_standard___collection___hash_collection___HashMapValues(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___hash_collection___HashMapValues;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___hash_collection___HashMapValues_____atmap(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@map", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_HashMapValues_standard___collection___hash_collection___HashMapValues___init[] = "new HashMapValues hash_collection::HashMapValues::init";
val_t NEW_HashMapValues_standard___collection___hash_collection___HashMapValues___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[4] = {0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_NEW_HashMapValues_standard___collection___hash_collection___HashMapValues___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = NEW_standard___collection___hash_collection___HashMapValues();
  INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapValues(fra.me.REG[1]);
  standard___collection___hash_collection___HashMapValues___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___hash_collection___HashMapValues(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___collection___hash_collection___HashMapNode[56] = {
  {(bigint) 127 /* 0: Identity */},
  {(bigint) 8 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "HashMapNode" /* 2: Class Name */},
  {(bigint) 3 /* 3: HashMapNode < Object: superclass typecheck marker */},
  {(bigint) 47 /* 4: HashMapNode < HashNode: superclass typecheck marker */},
  {(bigint) 127 /* 5: HashMapNode < HashMapNode: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 1 /* 17: HashMapNode < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 0 /* 46: HashMapNode < HashNode: superclass init_table position */},
  {(bigint) 127 /* 47: VT HashMapNode::N : id of HashMapNode */},
  {(bigint) 5 /* 48: VT HashMapNode::N : color of HashMapNode */},
  {(bigint) standard___collection___hash_collection___HashNode___next_item},
  {(bigint) standard___collection___hash_collection___HashNode___next_item__eq},
  {(bigint) standard___collection___hash_collection___HashNode___prev_item},
  {(bigint) standard___collection___hash_collection___HashNode___prev_item__eq},
  {(bigint) standard___collection___hash_collection___HashNode___init},
  {(bigint) 2 /* 54: HashMapNode < HashMapNode: superclass init_table position */},
  {(bigint) standard___collection___hash_collection___HashMapNode___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute HashMapNode::_key */
/* 3: Attribute HashMapNode::_next_item */
/* 4: Attribute HashMapNode::_prev_item */
/* 5: Attribute HashMapNode::_prev_in_bucklet */
/* 6: Attribute HashMapNode::_next_in_bucklet */
/* 7: Attribute HashMapNode::_value */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapNode[] = "init var of HashMapNode";
void INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapNode(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapNode;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:192 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___collection___hash_collection___HashNode____next_item(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:193 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___collection___hash_collection___HashNode____prev_item(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:194 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___collection___hash_collection___HashNode____prev_in_bucklet(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:195 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___collection___hash_collection___HashNode____next_in_bucklet(fra.me.REG[0]) = fra.me.REG[1];
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___hash_collection___HashMapNode(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 8);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___hash_collection___HashMapNode;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___hash_collection___HashMapNode[] = "check new HashMapNode";
void CHECKNEW_standard___collection___hash_collection___HashMapNode(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___hash_collection___HashMapNode;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___hash_collection___HashNode____key(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_key", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_HashMapNode_standard___collection___hash_collection___HashMapNode___init[] = "new HashMapNode hash_collection::HashMapNode::init";
val_t NEW_HashMapNode_standard___collection___hash_collection___HashMapNode___init(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[2];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 356;
  fra.me.meth = LOCATE_NEW_HashMapNode_standard___collection___hash_collection___HashMapNode___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 3;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[2] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = p1;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:356 */
  fra.me.REG[2] = NEW_standard___collection___hash_collection___HashMapNode();
  INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapNode(fra.me.REG[2]);
  standard___collection___hash_collection___HashMapNode___init(fra.me.REG[2], fra.me.REG[0], fra.me.REG[1], init_table);
  CHECKNEW_standard___collection___hash_collection___HashMapNode(fra.me.REG[2]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[2];
}
const classtable_elt_t VFT_standard___collection___hash_collection___HashMapIterator[53] = {
  {(bigint) 131 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "HashMapIterator" /* 2: Class Name */},
  {(bigint) 3 /* 3: HashMapIterator < Object: superclass typecheck marker */},
  {(bigint) 35 /* 4: HashMapIterator < MapIterator: superclass typecheck marker */},
  {(bigint) 131 /* 5: HashMapIterator < HashMapIterator: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 1 /* 17: HashMapIterator < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 0 /* 46: HashMapIterator < MapIterator: superclass init_table position */},
  {(bigint) standard___collection___hash_collection___HashMapIterator___item},
  {(bigint) standard___collection___hash_collection___HashMapIterator___key},
  {(bigint) standard___collection___hash_collection___HashMapIterator___next},
  {(bigint) standard___collection___hash_collection___HashMapIterator___is_ok},
  {(bigint) 2 /* 51: HashMapIterator < HashMapIterator: superclass init_table position */},
  {(bigint) standard___collection___hash_collection___HashMapIterator___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute HashMapIterator::_map */
/* 3: Attribute HashMapIterator::_node */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapIterator[] = "init var of HashMapIterator";
void INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___hash_collection___HashMapIterator(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___hash_collection___HashMapIterator;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___hash_collection___HashMapIterator[] = "check new HashMapIterator";
void CHECKNEW_standard___collection___hash_collection___HashMapIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___hash_collection___HashMapIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___hash_collection___HashMapIterator____map(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_map", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_HashMapIterator_standard___collection___hash_collection___HashMapIterator___init[] = "new HashMapIterator hash_collection::HashMapIterator::init";
val_t NEW_HashMapIterator_standard___collection___hash_collection___HashMapIterator___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 397;
  fra.me.meth = LOCATE_NEW_HashMapIterator_standard___collection___hash_collection___HashMapIterator___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:397 */
  fra.me.REG[1] = NEW_standard___collection___hash_collection___HashMapIterator();
  INIT_ATTRIBUTES__standard___collection___hash_collection___HashMapIterator(fra.me.REG[1]);
  standard___collection___hash_collection___HashMapIterator___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___hash_collection___HashMapIterator(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___collection___hash_collection___HashSet[92] = {
  {(bigint) 295 /* 0: Identity */},
  {(bigint) 9 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "HashSet" /* 2: Class Name */},
  {(bigint) 3 /* 3: HashSet < Object: superclass typecheck marker */},
  {(bigint) 255 /* 4: HashSet < Set: superclass typecheck marker */},
  {(bigint) 67 /* 5: HashSet < ArrayCapable: superclass typecheck marker */},
  {(bigint) 59 /* 6: HashSet < Collection: superclass typecheck marker */},
  {(bigint) 135 /* 7: HashSet < HashCollection: superclass typecheck marker */},
  {(bigint) 79 /* 8: HashSet < RemovableCollection: superclass typecheck marker */},
  {(bigint) 175 /* 9: HashSet < SimpleCollection: superclass typecheck marker */},
  {(bigint) 295 /* 10: HashSet < HashSet: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 4 /* 17: HashSet < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Collection___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 0 /* 46: HashSet < Set: superclass init_table position */},
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 48: HashSet < SimpleCollection: superclass init_table position */},
  {(bigint) standard___collection___hash_collection___HashSet___add},
  {(bigint) standard___collection___abstract_collection___SimpleCollection___add_all},
  {(bigint) 7 /* 51: HashSet < HashSet: superclass init_table position */},
  {(bigint) standard___collection___hash_collection___HashSet___init},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 6 /* 55: HashSet < ArrayCapable: superclass init_table position */},
  {(bigint) standard___collection___array___ArrayCapable___calloc_array},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___string___Collection___join},
  {(bigint) standard___collection___array___Collection___to_a},
  {(bigint) 3 /* 64: HashSet < Collection: superclass init_table position */},
  {(bigint) standard___collection___hash_collection___HashSet___iterator},
  {(bigint) standard___collection___abstract_collection___Collection___iterate},
  {(bigint) standard___collection___hash_collection___HashSet___is_empty},
  {(bigint) standard___collection___hash_collection___HashSet___length},
  {(bigint) standard___collection___hash_collection___HashSet___has},
  {(bigint) standard___collection___abstract_collection___Set___has_only},
  {(bigint) standard___collection___abstract_collection___Set___count},
  {(bigint) standard___collection___hash_collection___HashSet___first},
  {(bigint) standard___math___Collection___rand},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 2 /* 78: HashSet < RemovableCollection: superclass init_table position */},
  {(bigint) standard___collection___hash_collection___HashSet___clear},
  {(bigint) standard___collection___hash_collection___HashSet___remove},
  {(bigint) standard___collection___abstract_collection___Set___remove_all},
  {(bigint) 5 /* 82: HashSet < HashCollection: superclass init_table position */},
  {(bigint) standard___collection___hash_collection___HashCollection___first_item},
  {(bigint) standard___collection___hash_collection___HashCollection___index_at},
  {(bigint) standard___collection___hash_collection___HashCollection___node_at},
  {(bigint) standard___collection___hash_collection___HashCollection___node_at_idx},
  {(bigint) standard___collection___hash_collection___HashCollection___store},
  {(bigint) standard___collection___hash_collection___HashCollection___remove_node},
  {(bigint) standard___collection___hash_collection___HashCollection___raz},
  {(bigint) standard___collection___hash_collection___HashCollection___enlarge},
  {(bigint) standard___collection___hash_collection___HashCollection___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute HashSet::_array */
/* 3: Attribute HashSet::_capacity */
/* 4: Attribute HashSet::_length */
/* 5: Attribute HashSet::_first_item */
/* 6: Attribute HashSet::_last_item */
/* 7: Attribute HashSet::_last_accessed_key */
/* 8: Attribute HashSet::_last_accessed_node */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___hash_collection___HashSet[] = "init var of HashSet";
void INIT_ATTRIBUTES__standard___collection___hash_collection___HashSet(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___hash_collection___HashSet;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:23 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___collection___hash_collection___HashCollection____array(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:24 */
  REGB0 = TAG_Int(0);
  ATTR_standard___collection___hash_collection___HashCollection____capacity(fra.me.REG[0]) = REGB0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:25 */
  REGB0 = TAG_Int(0);
  ATTR_standard___collection___hash_collection___HashCollection____length(fra.me.REG[0]) = REGB0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:27 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___collection___hash_collection___HashCollection____first_item(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:28 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___collection___hash_collection___HashCollection____last_item(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:30 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___collection___hash_collection___HashCollection____last_accessed_key(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:33 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___collection___hash_collection___HashCollection____last_accessed_node(fra.me.REG[0]) = fra.me.REG[1];
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___hash_collection___HashSet(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 9);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___hash_collection___HashSet;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___hash_collection___HashSet[] = "check new HashSet";
void CHECKNEW_standard___collection___hash_collection___HashSet(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___hash_collection___HashSet;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___hash_collection___HashCollection____capacity(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_capacity", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___collection___hash_collection___HashCollection____length(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_length", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_HashSet_standard___collection___hash_collection___HashSet___init[] = "new HashSet hash_collection::HashSet::init";
val_t NEW_HashSet_standard___collection___hash_collection___HashSet___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 442;
  fra.me.meth = LOCATE_NEW_HashSet_standard___collection___hash_collection___HashSet___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:442 */
  fra.me.REG[0] = NEW_standard___collection___hash_collection___HashSet();
  INIT_ATTRIBUTES__standard___collection___hash_collection___HashSet(fra.me.REG[0]);
  standard___collection___hash_collection___HashSet___init(fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___hash_collection___HashSet(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_standard___collection___hash_collection___HashSetNode[56] = {
  {(bigint) 119 /* 0: Identity */},
  {(bigint) 7 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "HashSetNode" /* 2: Class Name */},
  {(bigint) 3 /* 3: HashSetNode < Object: superclass typecheck marker */},
  {(bigint) 47 /* 4: HashSetNode < HashNode: superclass typecheck marker */},
  {(bigint) 119 /* 5: HashSetNode < HashSetNode: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 1 /* 17: HashSetNode < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 0 /* 46: HashSetNode < HashNode: superclass init_table position */},
  {(bigint) 119 /* 47: VT HashSetNode::N : id of HashSetNode */},
  {(bigint) 5 /* 48: VT HashSetNode::N : color of HashSetNode */},
  {(bigint) standard___collection___hash_collection___HashNode___next_item},
  {(bigint) standard___collection___hash_collection___HashNode___next_item__eq},
  {(bigint) standard___collection___hash_collection___HashNode___prev_item},
  {(bigint) standard___collection___hash_collection___HashNode___prev_item__eq},
  {(bigint) standard___collection___hash_collection___HashNode___init},
  {(bigint) 2 /* 54: HashSetNode < HashSetNode: superclass init_table position */},
  {(bigint) standard___collection___hash_collection___HashSetNode___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute HashSetNode::_key */
/* 3: Attribute HashSetNode::_next_item */
/* 4: Attribute HashSetNode::_prev_item */
/* 5: Attribute HashSetNode::_prev_in_bucklet */
/* 6: Attribute HashSetNode::_next_in_bucklet */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___hash_collection___HashSetNode[] = "init var of HashSetNode";
void INIT_ATTRIBUTES__standard___collection___hash_collection___HashSetNode(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___hash_collection___HashSetNode;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:192 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___collection___hash_collection___HashNode____next_item(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:193 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___collection___hash_collection___HashNode____prev_item(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:194 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___collection___hash_collection___HashNode____prev_in_bucklet(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:195 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___collection___hash_collection___HashNode____next_in_bucklet(fra.me.REG[0]) = fra.me.REG[1];
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___hash_collection___HashSetNode(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 7);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___hash_collection___HashSetNode;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___hash_collection___HashSetNode[] = "check new HashSetNode";
void CHECKNEW_standard___collection___hash_collection___HashSetNode(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___hash_collection___HashSetNode;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___hash_collection___HashNode____key(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_key", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_HashSetNode_standard___collection___hash_collection___HashSetNode___init[] = "new HashSetNode hash_collection::HashSetNode::init";
val_t NEW_HashSetNode_standard___collection___hash_collection___HashSetNode___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 454;
  fra.me.meth = LOCATE_NEW_HashSetNode_standard___collection___hash_collection___HashSetNode___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:454 */
  fra.me.REG[1] = NEW_standard___collection___hash_collection___HashSetNode();
  INIT_ATTRIBUTES__standard___collection___hash_collection___HashSetNode(fra.me.REG[1]);
  standard___collection___hash_collection___HashSetNode___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___hash_collection___HashSetNode(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___collection___hash_collection___HashSetIterator[53] = {
  {(bigint) 123 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "HashSetIterator" /* 2: Class Name */},
  {(bigint) 3 /* 3: HashSetIterator < Object: superclass typecheck marker */},
  {(bigint) 39 /* 4: HashSetIterator < Iterator: superclass typecheck marker */},
  {(bigint) 123 /* 5: HashSetIterator < HashSetIterator: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 1 /* 17: HashSetIterator < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) standard___collection___array___Iterator___to_a},
  {(bigint) 0 /* 47: HashSetIterator < Iterator: superclass init_table position */},
  {(bigint) standard___collection___hash_collection___HashSetIterator___item},
  {(bigint) standard___collection___hash_collection___HashSetIterator___next},
  {(bigint) standard___collection___hash_collection___HashSetIterator___is_ok},
  {(bigint) 2 /* 51: HashSetIterator < HashSetIterator: superclass init_table position */},
  {(bigint) standard___collection___hash_collection___HashSetIterator___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute HashSetIterator::_set */
/* 3: Attribute HashSetIterator::_node */
static const char LOCATE_INIT_ATTRIBUTES__standard___collection___hash_collection___HashSetIterator[] = "init var of HashSetIterator";
void INIT_ATTRIBUTES__standard___collection___hash_collection___HashSetIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___collection___hash_collection___HashSetIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___collection___hash_collection___HashSetIterator(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_standard___collection___hash_collection___HashSetIterator;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___collection___hash_collection___HashSetIterator[] = "check new HashSetIterator";
void CHECKNEW_standard___collection___hash_collection___HashSetIterator(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___collection___hash_collection___HashSetIterator;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___collection___hash_collection___HashSetIterator____set(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_set", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_HashSetIterator_standard___collection___hash_collection___HashSetIterator___init[] = "new HashSetIterator hash_collection::HashSetIterator::init";
val_t NEW_HashSetIterator_standard___collection___hash_collection___HashSetIterator___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 482;
  fra.me.meth = LOCATE_NEW_HashSetIterator_standard___collection___hash_collection___HashSetIterator___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/hash_collection.nit:482 */
  fra.me.REG[1] = NEW_standard___collection___hash_collection___HashSetIterator();
  INIT_ATTRIBUTES__standard___collection___hash_collection___HashSetIterator(fra.me.REG[1]);
  standard___collection___hash_collection___HashSetIterator___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___collection___hash_collection___HashSetIterator(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___string___String[137] = {
  {(bigint) 283 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "String" /* 2: Class Name */},
  {(bigint) 3 /* 3: String < Object: superclass typecheck marker */},
  {(bigint) 19 /* 4: String < Pattern: superclass typecheck marker */},
  {(bigint) 55 /* 5: String < Comparable: superclass typecheck marker */},
  {(bigint) 59 /* 6: String < Collection: superclass typecheck marker */},
  {(bigint) 75 /* 7: String < SequenceRead: superclass typecheck marker */},
  {(bigint) 283 /* 8: String < String: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 243 /* 10: String < AbstractArrayRead: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 279 /* 12: String < AbstractString: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 1 /* 17: String < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___string___String_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___string___AbstractString___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___String___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___string___String___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 6 /* 46: String < Pattern: superclass init_table position */},
  {(bigint) standard___string_search___String___search_index_in},
  {(bigint) standard___string_search___String___search_in},
  {(bigint) standard___string_search___Pattern___search_all_in},
  {(bigint) standard___string_search___Pattern___split_in},
  {(bigint) 0 /* 51: String < Comparable: superclass init_table position */},
  {(bigint) 283 /* 52: VT String::OTHER : id of String */},
  {(bigint) 8 /* 53: VT String::OTHER : color of String */},
  {(bigint) standard___string___String_____l},
  {(bigint) standard___kernel___Comparable_____leq},
  {(bigint) standard___kernel___Comparable_____geq},
  {(bigint) standard___kernel___Comparable_____g},
  {(bigint) standard___kernel___Comparable_____leqg},
  {(bigint) standard___kernel___Comparable___is_between},
  {(bigint) standard___kernel___Comparable___max},
  {(bigint) standard___kernel___Comparable___min},
  {(bigint) standard___string___Collection___join},
  {(bigint) standard___collection___array___Collection___to_a},
  {(bigint) 5 /* 64: String < Collection: superclass init_table position */},
  {(bigint) standard___collection___array___AbstractArrayRead___iterator},
  {(bigint) standard___collection___abstract_collection___Collection___iterate},
  {(bigint) standard___collection___array___AbstractArrayRead___is_empty},
  {(bigint) standard___collection___array___AbstractArrayRead___length},
  {(bigint) standard___collection___array___AbstractArrayRead___has},
  {(bigint) standard___collection___array___AbstractArrayRead___has_only},
  {(bigint) standard___collection___array___AbstractArrayRead___count},
  {(bigint) standard___collection___abstract_collection___SequenceRead___first},
  {(bigint) standard___math___Collection___rand},
  {(bigint) 4 /* 74: String < SequenceRead: superclass init_table position */},
  {(bigint) standard___string___AbstractString_____bra},
  {(bigint) standard___collection___abstract_collection___SequenceRead___last},
  {(bigint) standard___collection___array___AbstractArrayRead___index_of},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 3 /* 82: String < AbstractArrayRead: superclass init_table position */},
  {(bigint) standard___collection___array___AbstractArrayRead___last_index_of},
  {(bigint) standard___collection___array___AbstractArrayRead___index_of_from},
  {(bigint) standard___collection___array___AbstractArrayRead___last_index_of_from},
  {(bigint) standard___collection___array___AbstractArrayRead___reversed},
  {(bigint) standard___collection___array___AbstractArrayRead___copy_to},
  {(bigint) standard___collection___array___AbstractArrayRead___init},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 2 /* 99: String < AbstractString: superclass init_table position */},
  {(bigint) standard___string___AbstractString___items},
  {(bigint) standard___string___AbstractString___substring},
  {(bigint) standard___string___AbstractString___substring_from},
  {(bigint) standard___string___AbstractString___has_substring},
  {(bigint) standard___string___AbstractString___has_prefix},
  {(bigint) standard___string___AbstractString___has_suffix},
  {(bigint) standard___string___AbstractString___to_i},
  {(bigint) standard___string___AbstractString___to_hex},
  {(bigint) standard___string___AbstractString___a_to},
  {(bigint) standard___string___AbstractString___to_upper},
  {(bigint) standard___string___AbstractString___to_lower},
  {(bigint) standard___environ___String___environ},
  {(bigint) 7 /* 112: String < String: superclass init_table position */},
  {(bigint) standard___string___String___with_native},
  {(bigint) standard___string___String___from_cstring},
  {(bigint) standard___string___String___to_cstring},
  {(bigint) standard___string___String_____plus},
  {(bigint) standard___string___String_____star},
  {(bigint) standard___string___String___to_f},
  {(bigint) standard___file___String___file_exists},
  {(bigint) standard___file___String___file_stat},
  {(bigint) standard___file___String___file_delete},
  {(bigint) standard___file___String___strip_extension},
  {(bigint) standard___file___String___basename},
  {(bigint) standard___file___String___dirname},
  {(bigint) standard___file___String___simplify_path},
  {(bigint) standard___file___String___join_path},
  {(bigint) standard___file___String___mkdir},
  {(bigint) standard___file___String___file_extension},
  {(bigint) standard___file___String___files},
  {(bigint) standard___string_search___String___search},
  {(bigint) standard___string_search___String___search_from},
  {(bigint) standard___string_search___String___search_all},
  {(bigint) standard___string_search___String___split_with},
  {(bigint) standard___string_search___String___split},
  {(bigint) standard___string_search___String___replace},
  {(bigint) standard___string_search___String___html_escape},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute String::_length */
/* 3: Attribute String::_items */
static const char LOCATE_INIT_ATTRIBUTES__standard___string___String[] = "init var of String";
void INIT_ATTRIBUTES__standard___string___String(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___string___String;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/array.nit:24 */
  REGB0 = TAG_Int(0);
  ATTR_standard___collection___array___AbstractArrayRead____length(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___string___String(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_standard___string___String;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___string___String[] = "check new String";
void CHECKNEW_standard___string___String(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___string___String;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___string___AbstractString____items(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_items", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___collection___array___AbstractArrayRead____length(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_length", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_String_standard___string___String___with_native[] = "new String string::String::with_native";
val_t NEW_String_standard___string___String___with_native(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t REGB0;
  val_t tmp;
  int init_table[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 170;
  fra.me.meth = LOCATE_NEW_String_standard___string___String___with_native;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = p1;
  /* /home/jp/Projects-ssd/nit/lib/standard/string.nit:170 */
  fra.me.REG[1] = NEW_standard___string___String();
  INIT_ATTRIBUTES__standard___string___String(fra.me.REG[1]);
  standard___string___String___with_native(fra.me.REG[1], fra.me.REG[0], REGB0, init_table);
  CHECKNEW_standard___string___String(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
static const char LOCATE_NEW_String_standard___string___String___from_cstring[] = "new String string::String::from_cstring";
val_t NEW_String_standard___string___String___from_cstring(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 178;
  fra.me.meth = LOCATE_NEW_String_standard___string___String___from_cstring;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/string.nit:178 */
  fra.me.REG[1] = NEW_standard___string___String();
  INIT_ATTRIBUTES__standard___string___String(fra.me.REG[1]);
  standard___string___String___from_cstring(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___string___String(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___string___Buffer[121] = {
  {(bigint) 307 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "Buffer" /* 2: Class Name */},
  {(bigint) 3 /* 3: Buffer < Object: superclass typecheck marker */},
  {(bigint) 11 /* 4: Buffer < StringCapable: superclass typecheck marker */},
  {(bigint) 55 /* 5: Buffer < Comparable: superclass typecheck marker */},
  {(bigint) 59 /* 6: Buffer < Collection: superclass typecheck marker */},
  {(bigint) 75 /* 7: Buffer < SequenceRead: superclass typecheck marker */},
  {(bigint) 79 /* 8: Buffer < RemovableCollection: superclass typecheck marker */},
  {(bigint) 175 /* 9: Buffer < SimpleCollection: superclass typecheck marker */},
  {(bigint) 243 /* 10: Buffer < AbstractArrayRead: superclass typecheck marker */},
  {(bigint) 259 /* 11: Buffer < Sequence: superclass typecheck marker */},
  {(bigint) 279 /* 12: Buffer < AbstractString: superclass typecheck marker */},
  {(bigint) 303 /* 13: Buffer < AbstractArray: superclass typecheck marker */},
  {(bigint) 307 /* 14: Buffer < Buffer: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 4 /* 17: Buffer < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___string___Buffer_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___string___AbstractString___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Buffer___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 6 /* 46: Buffer < StringCapable: superclass init_table position */},
  {(bigint) standard___string___StringCapable___calloc_string},
  {(bigint) 9 /* 48: Buffer < SimpleCollection: superclass init_table position */},
  {(bigint) standard___string___Buffer___add},
  {(bigint) standard___collection___abstract_collection___SimpleCollection___add_all},
  {(bigint) 5 /* 51: Buffer < Comparable: superclass init_table position */},
  {(bigint) 283 /* 52: VT Buffer::OTHER : id of String */},
  {(bigint) 8 /* 53: VT Buffer::OTHER : color of String */},
  {(bigint) standard___string___Buffer_____l},
  {(bigint) standard___kernel___Comparable_____leq},
  {(bigint) standard___kernel___Comparable_____geq},
  {(bigint) standard___kernel___Comparable_____g},
  {(bigint) standard___kernel___Comparable_____leqg},
  {(bigint) standard___kernel___Comparable___is_between},
  {(bigint) standard___kernel___Comparable___max},
  {(bigint) standard___kernel___Comparable___min},
  {(bigint) standard___string___Collection___join},
  {(bigint) standard___collection___array___Collection___to_a},
  {(bigint) 3 /* 64: Buffer < Collection: superclass init_table position */},
  {(bigint) standard___collection___array___AbstractArrayRead___iterator},
  {(bigint) standard___collection___abstract_collection___Collection___iterate},
  {(bigint) standard___collection___array___AbstractArrayRead___is_empty},
  {(bigint) standard___collection___array___AbstractArrayRead___length},
  {(bigint) standard___collection___array___AbstractArrayRead___has},
  {(bigint) standard___collection___array___AbstractArrayRead___has_only},
  {(bigint) standard___collection___array___AbstractArrayRead___count},
  {(bigint) standard___collection___abstract_collection___SequenceRead___first},
  {(bigint) standard___math___Collection___rand},
  {(bigint) 2 /* 74: Buffer < SequenceRead: superclass init_table position */},
  {(bigint) standard___string___AbstractString_____bra},
  {(bigint) standard___collection___abstract_collection___SequenceRead___last},
  {(bigint) standard___collection___array___AbstractArrayRead___index_of},
  {(bigint) 10 /* 78: Buffer < RemovableCollection: superclass init_table position */},
  {(bigint) standard___collection___array___AbstractArray___clear},
  {(bigint) standard___collection___array___AbstractArray___remove},
  {(bigint) standard___collection___array___AbstractArray___remove_all},
  {(bigint) 1 /* 82: Buffer < AbstractArrayRead: superclass init_table position */},
  {(bigint) standard___collection___array___AbstractArrayRead___last_index_of},
  {(bigint) standard___collection___array___AbstractArrayRead___index_of_from},
  {(bigint) standard___collection___array___AbstractArrayRead___last_index_of_from},
  {(bigint) standard___collection___array___AbstractArrayRead___reversed},
  {(bigint) standard___collection___array___AbstractArrayRead___copy_to},
  {(bigint) standard___collection___array___AbstractArrayRead___init},
  {(bigint) 8 /* 89: Buffer < Sequence: superclass init_table position */},
  {(bigint) standard___collection___abstract_collection___Sequence___first__eq},
  {(bigint) standard___collection___abstract_collection___Sequence___last__eq},
  {(bigint) standard___collection___array___AbstractArray___push},
  {(bigint) standard___string___Buffer___append},
  {(bigint) standard___collection___array___AbstractArray___pop},
  {(bigint) standard___collection___array___AbstractArray___unshift},
  {(bigint) standard___collection___array___AbstractArray___shift},
  {(bigint) standard___string___Buffer_____braeq},
  {(bigint) standard___collection___array___AbstractArray___remove_at},
  {(bigint) 0 /* 99: Buffer < AbstractString: superclass init_table position */},
  {(bigint) standard___string___AbstractString___items},
  {(bigint) standard___string___AbstractString___substring},
  {(bigint) standard___string___AbstractString___substring_from},
  {(bigint) standard___string___AbstractString___has_substring},
  {(bigint) standard___string___AbstractString___has_prefix},
  {(bigint) standard___string___AbstractString___has_suffix},
  {(bigint) standard___string___AbstractString___to_i},
  {(bigint) standard___string___AbstractString___to_hex},
  {(bigint) standard___string___AbstractString___a_to},
  {(bigint) standard___string___AbstractString___to_upper},
  {(bigint) standard___string___AbstractString___to_lower},
  {(bigint) 7 /* 111: Buffer < AbstractArray: superclass init_table position */},
  {(bigint) standard___string___Buffer___enlarge},
  {(bigint) standard___collection___array___AbstractArray___insert},
  {(bigint) standard___collection___array___AbstractArray___swap_at},
  {(bigint) 11 /* 115: Buffer < Buffer: superclass init_table position */},
  {(bigint) standard___collection___abstract_collection___Sequence___append},
  {(bigint) standard___string___Buffer___init},
  {(bigint) standard___string___Buffer___from},
  {(bigint) standard___string___Buffer___with_capacity},
  {(bigint) standard___string___Buffer___capacity},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Buffer::_length */
/* 3: Attribute Buffer::_items */
/* 4: Attribute Buffer::_capacity */
static const char LOCATE_INIT_ATTRIBUTES__standard___string___Buffer[] = "init var of Buffer";
void INIT_ATTRIBUTES__standard___string___Buffer(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___string___Buffer;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/collection/array.nit:24 */
  REGB0 = TAG_Int(0);
  ATTR_standard___collection___array___AbstractArrayRead____length(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___string___Buffer(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_standard___string___Buffer;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___string___Buffer[] = "check new Buffer";
void CHECKNEW_standard___string___Buffer(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___string___Buffer;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___string___Buffer____capacity(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_capacity", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___string___AbstractString____items(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_items", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___collection___array___AbstractArrayRead____length(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_length", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_Buffer_standard___string___Buffer___init[] = "new Buffer string::Buffer::init";
val_t NEW_Buffer_standard___string___Buffer___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 354;
  fra.me.meth = LOCATE_NEW_Buffer_standard___string___Buffer___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  /* /home/jp/Projects-ssd/nit/lib/standard/string.nit:354 */
  fra.me.REG[0] = NEW_standard___string___Buffer();
  INIT_ATTRIBUTES__standard___string___Buffer(fra.me.REG[0]);
  standard___string___Buffer___init(fra.me.REG[0], init_table);
  CHECKNEW_standard___string___Buffer(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
static const char LOCATE_NEW_Buffer_standard___string___Buffer___from[] = "new Buffer string::Buffer::from";
val_t NEW_Buffer_standard___string___Buffer___from(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 360;
  fra.me.meth = LOCATE_NEW_Buffer_standard___string___Buffer___from;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/string.nit:360 */
  fra.me.REG[1] = NEW_standard___string___Buffer();
  INIT_ATTRIBUTES__standard___string___Buffer(fra.me.REG[1]);
  standard___string___Buffer___from(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___string___Buffer(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
static const char LOCATE_NEW_Buffer_standard___string___Buffer___with_capacity[] = "new Buffer string::Buffer::with_capacity";
val_t NEW_Buffer_standard___string___Buffer___with_capacity(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  int init_table[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 368;
  fra.me.meth = LOCATE_NEW_Buffer_standard___string___Buffer___with_capacity;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  REGB0 = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/string.nit:368 */
  fra.me.REG[0] = NEW_standard___string___Buffer();
  INIT_ATTRIBUTES__standard___string___Buffer(fra.me.REG[0]);
  standard___string___Buffer___with_capacity(fra.me.REG[0], REGB0, init_table);
  CHECKNEW_standard___string___Buffer(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_standard___string___NativeString[59] = {
  {(bigint) -5 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "NativeString" /* 2: Class Name */},
  {(bigint) 3 /* 3: NativeString < Object: superclass typecheck marker */},
  {(bigint) -5 /* 4: NativeString < NativeString: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 0 /* 17: NativeString < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) standard___environ___NativeString___get_environ},
  {(bigint) 1 /* 47: NativeString < NativeString: superclass init_table position */},
  {(bigint) standard___string___NativeString_____bra},
  {(bigint) standard___string___NativeString_____braeq},
  {(bigint) standard___string___NativeString___copy_to},
  {(bigint) standard___string___NativeString___cstring_length},
  {(bigint) standard___string___NativeString___atoi},
  {(bigint) standard___string___NativeString___init},
  {(bigint) standard___file___NativeString___file_exists},
  {(bigint) standard___file___NativeString___file_stat},
  {(bigint) standard___file___NativeString___file_mkdir},
  {(bigint) standard___file___NativeString___file_delete},
  {(bigint) standard___exec___NativeString___system},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
val_t BOX_NativeString(char * val) {
  struct TBOX_NativeString *box = (struct TBOX_NativeString*)alloc(sizeof(struct TBOX_NativeString));
  box->vft = VFT_standard___string___NativeString;
  box->val = val;
  box->object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(box);
}
const classtable_elt_t VFT_standard___stream___FDIStream[72] = {
  {(bigint) 219 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "FDIStream" /* 2: Class Name */},
  {(bigint) 3 /* 3: FDIStream < Object: superclass typecheck marker */},
  {(bigint) 143 /* 4: FDIStream < FDStream: superclass typecheck marker */},
  {(bigint) 43 /* 5: FDIStream < IOS: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 115 /* 7: FDIStream < IStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 219 /* 9: FDIStream < FDIStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 2 /* 17: FDIStream < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 0 /* 46: FDIStream < FDStream: superclass init_table position */},
  {(bigint) standard___stream___FDStream___fd},
  {(bigint) standard___stream___FDStream___fd__eq},
  {(bigint) standard___stream___FDStream___native_close},
  {(bigint) standard___stream___FDStream___native_read_char},
  {(bigint) standard___stream___FDStream___native_read},
  {(bigint) standard___stream___FDStream___native_write},
  {(bigint) standard___stream___FDStream___init},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 57: FDIStream < IOS: superclass init_table position */},
  {(bigint) standard___stream___FDStream___close},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 3 /* 62: FDIStream < IStream: superclass init_table position */},
  {(bigint) standard___stream___FDIStream___read_char},
  {(bigint) standard___stream___IStream___read},
  {(bigint) standard___stream___IStream___read_line},
  {(bigint) standard___stream___IStream___read_all},
  {(bigint) standard___stream___IStream___append_line_to},
  {(bigint) standard___stream___FDIStream___eof},
  {(bigint) 4 /* 69: FDIStream < FDIStream: superclass init_table position */},
  {(bigint) standard___stream___FDIStream___eof__eq},
  {(bigint) standard___stream___FDIStream___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute FDIStream::@fd */
/* Instance Hole :( */
/* 4: Attribute FDIStream::@eof */
static const char LOCATE_INIT_ATTRIBUTES__standard___stream___FDIStream[] = "init var of FDIStream";
void INIT_ATTRIBUTES__standard___stream___FDIStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___stream___FDIStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/stream.nit:231 */
  REGB0 = TAG_Bool(0);
  ATTR_standard___stream___FDIStream_____ateof(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___stream___FDIStream(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_standard___stream___FDIStream;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___stream___FDIStream[] = "check new FDIStream";
void CHECKNEW_standard___stream___FDIStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___stream___FDIStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___stream___FDIStream_____ateof(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@eof", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___stream___FDStream_____atfd(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@fd", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_FDIStream_standard___stream___FDIStream___init[] = "new FDIStream stream::FDIStream::init";
val_t NEW_FDIStream_standard___stream___FDIStream___init(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  int init_table[5] = {0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 240;
  fra.me.meth = LOCATE_NEW_FDIStream_standard___stream___FDIStream___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  REGB0 = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/stream.nit:240 */
  fra.me.REG[0] = NEW_standard___stream___FDIStream();
  INIT_ATTRIBUTES__standard___stream___FDIStream(fra.me.REG[0]);
  standard___stream___FDIStream___init(fra.me.REG[0], REGB0, init_table);
  CHECKNEW_standard___stream___FDIStream(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_standard___stream___FDOStream[62] = {
  {(bigint) 215 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "FDOStream" /* 2: Class Name */},
  {(bigint) 3 /* 3: FDOStream < Object: superclass typecheck marker */},
  {(bigint) 143 /* 4: FDOStream < FDStream: superclass typecheck marker */},
  {(bigint) 43 /* 5: FDOStream < IOS: superclass typecheck marker */},
  {(bigint) 87 /* 6: FDOStream < OStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 215 /* 8: FDOStream < FDOStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 2 /* 17: FDOStream < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 0 /* 46: FDOStream < FDStream: superclass init_table position */},
  {(bigint) standard___stream___FDStream___fd},
  {(bigint) standard___stream___FDStream___fd__eq},
  {(bigint) standard___stream___FDStream___native_close},
  {(bigint) standard___stream___FDStream___native_read_char},
  {(bigint) standard___stream___FDStream___native_read},
  {(bigint) standard___stream___FDStream___native_write},
  {(bigint) standard___stream___FDStream___init},
  {(bigint) 4 /* 54: FDOStream < FDOStream: superclass init_table position */},
  {(bigint) standard___stream___FDOStream___is_writable__eq},
  {(bigint) standard___stream___FDOStream___init},
  {(bigint) 1 /* 57: FDOStream < IOS: superclass init_table position */},
  {(bigint) standard___stream___FDStream___close},
  {(bigint) 3 /* 59: FDOStream < OStream: superclass init_table position */},
  {(bigint) standard___stream___FDOStream___write},
  {(bigint) standard___stream___FDOStream___is_writable},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute FDOStream::@fd */
/* 3: Attribute FDOStream::@is_writable */
static const char LOCATE_INIT_ATTRIBUTES__standard___stream___FDOStream[] = "init var of FDOStream";
void INIT_ATTRIBUTES__standard___stream___FDOStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___stream___FDOStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___stream___FDOStream(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_standard___stream___FDOStream;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___stream___FDOStream[] = "check new FDOStream";
void CHECKNEW_standard___stream___FDOStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___stream___FDOStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___stream___FDOStream_____atis_writable(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@is_writable", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___stream___FDStream_____atfd(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@fd", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_FDOStream_standard___stream___FDOStream___init[] = "new FDOStream stream::FDOStream::init";
val_t NEW_FDOStream_standard___stream___FDOStream___init(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  int init_table[5] = {0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 254;
  fra.me.meth = LOCATE_NEW_FDOStream_standard___stream___FDOStream___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  REGB0 = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/stream.nit:254 */
  fra.me.REG[0] = NEW_standard___stream___FDOStream();
  INIT_ATTRIBUTES__standard___stream___FDOStream(fra.me.REG[0]);
  standard___stream___FDOStream___init(fra.me.REG[0], REGB0, init_table);
  CHECKNEW_standard___stream___FDOStream(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_standard___stream___FDIOStream[80] = {
  {(bigint) 271 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "FDIOStream" /* 2: Class Name */},
  {(bigint) 3 /* 3: FDIOStream < Object: superclass typecheck marker */},
  {(bigint) 143 /* 4: FDIOStream < FDStream: superclass typecheck marker */},
  {(bigint) 43 /* 5: FDIOStream < IOS: superclass typecheck marker */},
  {(bigint) 87 /* 6: FDIOStream < OStream: superclass typecheck marker */},
  {(bigint) 115 /* 7: FDIOStream < IStream: superclass typecheck marker */},
  {(bigint) 215 /* 8: FDIOStream < FDOStream: superclass typecheck marker */},
  {(bigint) 219 /* 9: FDIOStream < FDIStream: superclass typecheck marker */},
  {(bigint) 199 /* 10: FDIOStream < IOStream: superclass typecheck marker */},
  {(bigint) 271 /* 11: FDIOStream < FDIOStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 2 /* 17: FDIOStream < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 0 /* 46: FDIOStream < FDStream: superclass init_table position */},
  {(bigint) standard___stream___FDStream___fd},
  {(bigint) standard___stream___FDStream___fd__eq},
  {(bigint) standard___stream___FDStream___native_close},
  {(bigint) standard___stream___FDStream___native_read_char},
  {(bigint) standard___stream___FDStream___native_read},
  {(bigint) standard___stream___FDStream___native_write},
  {(bigint) standard___stream___FDStream___init},
  {(bigint) 6 /* 54: FDIOStream < FDOStream: superclass init_table position */},
  {(bigint) standard___stream___FDOStream___is_writable__eq},
  {(bigint) standard___stream___FDOStream___init},
  {(bigint) 1 /* 57: FDIOStream < IOS: superclass init_table position */},
  {(bigint) standard___stream___FDStream___close},
  {(bigint) 5 /* 59: FDIOStream < OStream: superclass init_table position */},
  {(bigint) standard___stream___FDOStream___write},
  {(bigint) standard___stream___FDOStream___is_writable},
  {(bigint) 3 /* 62: FDIOStream < IStream: superclass init_table position */},
  {(bigint) standard___stream___FDIStream___read_char},
  {(bigint) standard___stream___IStream___read},
  {(bigint) standard___stream___IStream___read_line},
  {(bigint) standard___stream___IStream___read_all},
  {(bigint) standard___stream___IStream___append_line_to},
  {(bigint) standard___stream___FDIStream___eof},
  {(bigint) 4 /* 69: FDIOStream < FDIStream: superclass init_table position */},
  {(bigint) standard___stream___FDIStream___eof__eq},
  {(bigint) standard___stream___FDIStream___init},
  {(bigint) 8 /* 72: FDIOStream < FDIOStream: superclass init_table position */},
  {(bigint) standard___stream___FDIOStream___init},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 7 /* 79: FDIOStream < IOStream: superclass init_table position */},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute FDIOStream::@fd */
/* 3: Attribute FDIOStream::@is_writable */
/* 4: Attribute FDIOStream::@eof */
static const char LOCATE_INIT_ATTRIBUTES__standard___stream___FDIOStream[] = "init var of FDIOStream";
void INIT_ATTRIBUTES__standard___stream___FDIOStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___stream___FDIOStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/stream.nit:231 */
  REGB0 = TAG_Bool(0);
  ATTR_standard___stream___FDIStream_____ateof(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___stream___FDIOStream(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_standard___stream___FDIOStream;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___stream___FDIOStream[] = "check new FDIOStream";
void CHECKNEW_standard___stream___FDIOStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___stream___FDIOStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___stream___FDIStream_____ateof(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@eof", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___stream___FDStream_____atfd(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@fd", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___stream___FDOStream_____atis_writable(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@is_writable", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_FDIOStream_standard___stream___FDIOStream___init[] = "new FDIOStream stream::FDIOStream::init";
val_t NEW_FDIOStream_standard___stream___FDIOStream___init(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  int init_table[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 264;
  fra.me.meth = LOCATE_NEW_FDIOStream_standard___stream___FDIOStream___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  REGB0 = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/stream.nit:264 */
  fra.me.REG[0] = NEW_standard___stream___FDIOStream();
  INIT_ATTRIBUTES__standard___stream___FDIOStream(fra.me.REG[0]);
  standard___stream___FDIOStream___init(fra.me.REG[0], REGB0, init_table);
  CHECKNEW_standard___stream___FDIOStream(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_standard___string_search___BM_Pattern[57] = {
  {(bigint) 167 /* 0: Identity */},
  {(bigint) 6 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "BM_Pattern" /* 2: Class Name */},
  {(bigint) 3 /* 3: BM_Pattern < Object: superclass typecheck marker */},
  {(bigint) 19 /* 4: BM_Pattern < Pattern: superclass typecheck marker */},
  {(bigint) 167 /* 5: BM_Pattern < BM_Pattern: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 1 /* 17: BM_Pattern < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string_search___BM_Pattern___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 0 /* 46: BM_Pattern < Pattern: superclass init_table position */},
  {(bigint) standard___string_search___BM_Pattern___search_index_in},
  {(bigint) standard___string_search___BM_Pattern___search_in},
  {(bigint) standard___string_search___Pattern___search_all_in},
  {(bigint) standard___string_search___Pattern___split_in},
  {(bigint) 2 /* 51: BM_Pattern < BM_Pattern: superclass init_table position */},
  {(bigint) standard___string_search___BM_Pattern___init},
  {(bigint) standard___string_search___BM_Pattern___bc},
  {(bigint) standard___string_search___BM_Pattern___compute_bc},
  {(bigint) standard___string_search___BM_Pattern___suffixes},
  {(bigint) standard___string_search___BM_Pattern___compute_gs},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute BM_Pattern::_motif */
/* 3: Attribute BM_Pattern::_length */
/* 4: Attribute BM_Pattern::_gs */
/* 5: Attribute BM_Pattern::_bc_table */
static const char LOCATE_INIT_ATTRIBUTES__standard___string_search___BM_Pattern[] = "init var of BM_Pattern";
void INIT_ATTRIBUTES__standard___string_search___BM_Pattern(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___string_search___BM_Pattern;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___string_search___BM_Pattern(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 6);
  obj->vft = (classtable_elt_t*)VFT_standard___string_search___BM_Pattern;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___string_search___BM_Pattern[] = "check new BM_Pattern";
void CHECKNEW_standard___string_search___BM_Pattern(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___string_search___BM_Pattern;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___string_search___BM_Pattern____motif(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_motif", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___string_search___BM_Pattern____length(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_length", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___string_search___BM_Pattern____gs(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_gs", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___string_search___BM_Pattern____bc_table(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_bc_table", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_BM_Pattern_standard___string_search___BM_Pattern___init[] = "new BM_Pattern string_search::BM_Pattern::init";
val_t NEW_BM_Pattern_standard___string_search___BM_Pattern___init(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[3] = {0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 107;
  fra.me.meth = LOCATE_NEW_BM_Pattern_standard___string_search___BM_Pattern___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/string_search.nit:107 */
  fra.me.REG[1] = NEW_standard___string_search___BM_Pattern();
  INIT_ATTRIBUTES__standard___string_search___BM_Pattern(fra.me.REG[1]);
  standard___string_search___BM_Pattern___init(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___string_search___BM_Pattern(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___string_search___Match[52] = {
  {(bigint) 27 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "Match" /* 2: Class Name */},
  {(bigint) 3 /* 3: Match < Object: superclass typecheck marker */},
  {(bigint) 27 /* 4: Match < Match: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 0 /* 17: Match < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string_search___Match___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 1 /* 46: Match < Match: superclass init_table position */},
  {(bigint) standard___string_search___Match___string},
  {(bigint) standard___string_search___Match___from},
  {(bigint) standard___string_search___Match___length},
  {(bigint) standard___string_search___Match___after},
  {(bigint) standard___string_search___Match___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Match::_string */
/* 3: Attribute Match::_from */
/* 4: Attribute Match::_length */
static const char LOCATE_INIT_ATTRIBUTES__standard___string_search___Match[] = "init var of Match";
void INIT_ATTRIBUTES__standard___string_search___Match(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___string_search___Match;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___string_search___Match(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_standard___string_search___Match;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___string_search___Match[] = "check new Match";
void CHECKNEW_standard___string_search___Match(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___string_search___Match;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___string_search___Match____string(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_string", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___string_search___Match____from(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_from", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___string_search___Match____length(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_length", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_Match_standard___string_search___Match___init[] = "new Match string_search::Match::init";
val_t NEW_Match_standard___string_search___Match___init(val_t p0, val_t p1, val_t p2){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t REGB0;
  val_t REGB1;
  val_t tmp;
  int init_table[2] = {0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 220;
  fra.me.meth = LOCATE_NEW_Match_standard___string_search___Match___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = p1;
  REGB1 = p2;
  /* /home/jp/Projects-ssd/nit/lib/standard/string_search.nit:220 */
  fra.me.REG[1] = NEW_standard___string_search___Match();
  INIT_ATTRIBUTES__standard___string_search___Match(fra.me.REG[1]);
  standard___string_search___Match___init(fra.me.REG[1], fra.me.REG[0], REGB0, REGB1, init_table);
  CHECKNEW_standard___string_search___Match(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___file___IFStream[74] = {
  {(bigint) 267 /* 0: Identity */},
  {(bigint) 7 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "IFStream" /* 2: Class Name */},
  {(bigint) 3 /* 3: IFStream < Object: superclass typecheck marker */},
  {(bigint) 139 /* 4: IFStream < FStream: superclass typecheck marker */},
  {(bigint) 43 /* 5: IFStream < IOS: superclass typecheck marker */},
  {(bigint) 227 /* 6: IFStream < BufferedIStream: superclass typecheck marker */},
  {(bigint) 115 /* 7: IFStream < IStream: superclass typecheck marker */},
  {(bigint) 267 /* 8: IFStream < IFStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 2 /* 17: IFStream < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 0 /* 46: IFStream < FStream: superclass init_table position */},
  {(bigint) standard___file___FStream___path},
  {(bigint) standard___file___FStream___file_stat},
  {(bigint) standard___file___FStream___init},
  {(bigint) 3 /* 50: IFStream < BufferedIStream: superclass init_table position */},
  {(bigint) standard___file___IFStream___fill_buffer},
  {(bigint) standard___file___IFStream___end_reached},
  {(bigint) standard___stream___BufferedIStream___prepare_buffer},
  {(bigint) standard___stream___BufferedIStream___init},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 57: IFStream < IOS: superclass init_table position */},
  {(bigint) standard___file___IFStream___close},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 4 /* 62: IFStream < IStream: superclass init_table position */},
  {(bigint) standard___stream___BufferedIStream___read_char},
  {(bigint) standard___stream___BufferedIStream___read},
  {(bigint) standard___stream___IStream___read_line},
  {(bigint) standard___stream___BufferedIStream___read_all},
  {(bigint) standard___stream___BufferedIStream___append_line_to},
  {(bigint) standard___stream___BufferedIStream___eof},
  {(bigint) 5 /* 69: IFStream < IFStream: superclass init_table position */},
  {(bigint) standard___file___IFStream___reopen},
  {(bigint) standard___file___IFStream___open},
  {(bigint) standard___file___IFStream___init},
  {(bigint) standard___file___IFStream___without_file},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute IFStream::_path */
/* 3: Attribute IFStream::_file */
/* 4: Attribute IFStream::_buffer */
/* 5: Attribute IFStream::_buffer_pos */
/* 6: Attribute IFStream::_end_reached */
static const char LOCATE_INIT_ATTRIBUTES__standard___file___IFStream[] = "init var of IFStream";
void INIT_ATTRIBUTES__standard___file___IFStream(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___file___IFStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/file.nit:99 */
  REGB0 = TAG_Bool(0);
  ATTR_standard___file___IFStream____end_reached(fra.me.REG[0]) = REGB0;
  /* /home/jp/Projects-ssd/nit/lib/standard/file.nit:54 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___file___FStream____path(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/file.nit:57 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___file___FStream____file(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/stream.nit:186 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___stream___BufferedIStream____buffer(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/stream.nit:190 */
  REGB0 = TAG_Int(0);
  ATTR_standard___stream___BufferedIStream____buffer_pos(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___file___IFStream(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 7);
  obj->vft = (classtable_elt_t*)VFT_standard___file___IFStream;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___file___IFStream[] = "check new IFStream";
void CHECKNEW_standard___file___IFStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___file___IFStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___file___IFStream____end_reached(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_end_reached", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___stream___BufferedIStream____buffer_pos(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_buffer_pos", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_IFStream_standard___file___IFStream___open[] = "new IFStream file::IFStream::open";
val_t NEW_IFStream_standard___file___IFStream___open(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[6] = {0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 101;
  fra.me.meth = LOCATE_NEW_IFStream_standard___file___IFStream___open;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/file.nit:101 */
  fra.me.REG[1] = NEW_standard___file___IFStream();
  INIT_ATTRIBUTES__standard___file___IFStream(fra.me.REG[1]);
  standard___file___IFStream___open(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___file___IFStream(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
static const char LOCATE_NEW_IFStream_standard___file___IFStream___init[] = "new IFStream file::IFStream::init";
val_t NEW_IFStream_standard___file___IFStream___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[6] = {0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 110;
  fra.me.meth = LOCATE_NEW_IFStream_standard___file___IFStream___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  /* /home/jp/Projects-ssd/nit/lib/standard/file.nit:110 */
  fra.me.REG[0] = NEW_standard___file___IFStream();
  INIT_ATTRIBUTES__standard___file___IFStream(fra.me.REG[0]);
  standard___file___IFStream___init(fra.me.REG[0], init_table);
  CHECKNEW_standard___file___IFStream(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
static const char LOCATE_NEW_IFStream_standard___file___IFStream___without_file[] = "new IFStream file::IFStream::without_file";
val_t NEW_IFStream_standard___file___IFStream___without_file(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[6] = {0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 111;
  fra.me.meth = LOCATE_NEW_IFStream_standard___file___IFStream___without_file;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  /* /home/jp/Projects-ssd/nit/lib/standard/file.nit:111 */
  fra.me.REG[0] = NEW_standard___file___IFStream();
  INIT_ATTRIBUTES__standard___file___IFStream(fra.me.REG[0]);
  standard___file___IFStream___without_file(fra.me.REG[0], init_table);
  CHECKNEW_standard___file___IFStream(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_standard___file___OFStream[62] = {
  {(bigint) 183 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "OFStream" /* 2: Class Name */},
  {(bigint) 3 /* 3: OFStream < Object: superclass typecheck marker */},
  {(bigint) 139 /* 4: OFStream < FStream: superclass typecheck marker */},
  {(bigint) 43 /* 5: OFStream < IOS: superclass typecheck marker */},
  {(bigint) 87 /* 6: OFStream < OStream: superclass typecheck marker */},
  {(bigint) 183 /* 7: OFStream < OFStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 2 /* 17: OFStream < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 0 /* 46: OFStream < FStream: superclass init_table position */},
  {(bigint) standard___file___FStream___path},
  {(bigint) standard___file___FStream___file_stat},
  {(bigint) standard___file___FStream___init},
  {(bigint) 4 /* 50: OFStream < OFStream: superclass init_table position */},
  {(bigint) standard___file___OFStream___write_native},
  {(bigint) standard___file___OFStream___open},
  {(bigint) standard___file___OFStream___init},
  {(bigint) standard___file___OFStream___without_file},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 57: OFStream < IOS: superclass init_table position */},
  {(bigint) standard___file___OFStream___close},
  {(bigint) 3 /* 59: OFStream < OStream: superclass init_table position */},
  {(bigint) standard___file___OFStream___write},
  {(bigint) standard___file___OFStream___is_writable},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute OFStream::_path */
/* 3: Attribute OFStream::_file */
/* 4: Attribute OFStream::_writable */
static const char LOCATE_INIT_ATTRIBUTES__standard___file___OFStream[] = "init var of OFStream";
void INIT_ATTRIBUTES__standard___file___OFStream(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___file___OFStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/file.nit:54 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___file___FStream____path(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/file.nit:57 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___file___FStream____file(fra.me.REG[0]) = fra.me.REG[1];
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___file___OFStream(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_standard___file___OFStream;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___file___OFStream[] = "check new OFStream";
void CHECKNEW_standard___file___OFStream(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___file___OFStream;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___file___OFStream____writable(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_writable", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_OFStream_standard___file___OFStream___open[] = "new OFStream file::OFStream::open";
val_t NEW_OFStream_standard___file___OFStream___open(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[5] = {0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 147;
  fra.me.meth = LOCATE_NEW_OFStream_standard___file___OFStream___open;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/file.nit:147 */
  fra.me.REG[1] = NEW_standard___file___OFStream();
  INIT_ATTRIBUTES__standard___file___OFStream(fra.me.REG[1]);
  standard___file___OFStream___open(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___file___OFStream(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
static const char LOCATE_NEW_OFStream_standard___file___OFStream___init[] = "new OFStream file::OFStream::init";
val_t NEW_OFStream_standard___file___OFStream___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[5] = {0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 156;
  fra.me.meth = LOCATE_NEW_OFStream_standard___file___OFStream___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  /* /home/jp/Projects-ssd/nit/lib/standard/file.nit:156 */
  fra.me.REG[0] = NEW_standard___file___OFStream();
  INIT_ATTRIBUTES__standard___file___OFStream(fra.me.REG[0]);
  standard___file___OFStream___init(fra.me.REG[0], init_table);
  CHECKNEW_standard___file___OFStream(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
static const char LOCATE_NEW_OFStream_standard___file___OFStream___without_file[] = "new OFStream file::OFStream::without_file";
val_t NEW_OFStream_standard___file___OFStream___without_file(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[5] = {0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 157;
  fra.me.meth = LOCATE_NEW_OFStream_standard___file___OFStream___without_file;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  /* /home/jp/Projects-ssd/nit/lib/standard/file.nit:157 */
  fra.me.REG[0] = NEW_standard___file___OFStream();
  INIT_ATTRIBUTES__standard___file___OFStream(fra.me.REG[0]);
  standard___file___OFStream___without_file(fra.me.REG[0], init_table);
  CHECKNEW_standard___file___OFStream(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_standard___file___Stdin[76] = {
  {(bigint) 287 /* 0: Identity */},
  {(bigint) 7 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "Stdin" /* 2: Class Name */},
  {(bigint) 3 /* 3: Stdin < Object: superclass typecheck marker */},
  {(bigint) 139 /* 4: Stdin < FStream: superclass typecheck marker */},
  {(bigint) 43 /* 5: Stdin < IOS: superclass typecheck marker */},
  {(bigint) 227 /* 6: Stdin < BufferedIStream: superclass typecheck marker */},
  {(bigint) 115 /* 7: Stdin < IStream: superclass typecheck marker */},
  {(bigint) 267 /* 8: Stdin < IFStream: superclass typecheck marker */},
  {(bigint) 287 /* 9: Stdin < Stdin: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 2 /* 17: Stdin < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 0 /* 46: Stdin < FStream: superclass init_table position */},
  {(bigint) standard___file___FStream___path},
  {(bigint) standard___file___FStream___file_stat},
  {(bigint) standard___file___FStream___init},
  {(bigint) 3 /* 50: Stdin < BufferedIStream: superclass init_table position */},
  {(bigint) standard___file___IFStream___fill_buffer},
  {(bigint) standard___file___IFStream___end_reached},
  {(bigint) standard___stream___BufferedIStream___prepare_buffer},
  {(bigint) standard___stream___BufferedIStream___init},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 57: Stdin < IOS: superclass init_table position */},
  {(bigint) standard___file___IFStream___close},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 4 /* 62: Stdin < IStream: superclass init_table position */},
  {(bigint) standard___stream___BufferedIStream___read_char},
  {(bigint) standard___stream___BufferedIStream___read},
  {(bigint) standard___stream___IStream___read_line},
  {(bigint) standard___stream___BufferedIStream___read_all},
  {(bigint) standard___stream___BufferedIStream___append_line_to},
  {(bigint) standard___stream___BufferedIStream___eof},
  {(bigint) 5 /* 69: Stdin < IFStream: superclass init_table position */},
  {(bigint) standard___file___IFStream___reopen},
  {(bigint) standard___file___IFStream___open},
  {(bigint) standard___file___IFStream___init},
  {(bigint) standard___file___IFStream___without_file},
  {(bigint) 6 /* 74: Stdin < Stdin: superclass init_table position */},
  {(bigint) standard___file___Stdin___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Stdin::_path */
/* 3: Attribute Stdin::_file */
/* 4: Attribute Stdin::_buffer */
/* 5: Attribute Stdin::_buffer_pos */
/* 6: Attribute Stdin::_end_reached */
static const char LOCATE_INIT_ATTRIBUTES__standard___file___Stdin[] = "init var of Stdin";
void INIT_ATTRIBUTES__standard___file___Stdin(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___file___Stdin;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/file.nit:99 */
  REGB0 = TAG_Bool(0);
  ATTR_standard___file___IFStream____end_reached(fra.me.REG[0]) = REGB0;
  /* /home/jp/Projects-ssd/nit/lib/standard/file.nit:54 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___file___FStream____path(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/file.nit:57 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___file___FStream____file(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/stream.nit:186 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___stream___BufferedIStream____buffer(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/stream.nit:190 */
  REGB0 = TAG_Int(0);
  ATTR_standard___stream___BufferedIStream____buffer_pos(fra.me.REG[0]) = REGB0;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___file___Stdin(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 7);
  obj->vft = (classtable_elt_t*)VFT_standard___file___Stdin;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___file___Stdin[] = "check new Stdin";
void CHECKNEW_standard___file___Stdin(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___file___Stdin;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___file___IFStream____end_reached(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_end_reached", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___stream___BufferedIStream____buffer_pos(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_buffer_pos", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_Stdin_standard___file___Stdin___init[] = "new Stdin file::Stdin::init";
val_t NEW_Stdin_standard___file___Stdin___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[7] = {0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 164;
  fra.me.meth = LOCATE_NEW_Stdin_standard___file___Stdin___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  /* /home/jp/Projects-ssd/nit/lib/standard/file.nit:164 */
  fra.me.REG[0] = NEW_standard___file___Stdin();
  INIT_ATTRIBUTES__standard___file___Stdin(fra.me.REG[0]);
  standard___file___Stdin___init(fra.me.REG[0], init_table);
  CHECKNEW_standard___file___Stdin(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_standard___file___Stdout[64] = {
  {(bigint) 247 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "Stdout" /* 2: Class Name */},
  {(bigint) 3 /* 3: Stdout < Object: superclass typecheck marker */},
  {(bigint) 139 /* 4: Stdout < FStream: superclass typecheck marker */},
  {(bigint) 43 /* 5: Stdout < IOS: superclass typecheck marker */},
  {(bigint) 87 /* 6: Stdout < OStream: superclass typecheck marker */},
  {(bigint) 183 /* 7: Stdout < OFStream: superclass typecheck marker */},
  {(bigint) 247 /* 8: Stdout < Stdout: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 2 /* 17: Stdout < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 0 /* 46: Stdout < FStream: superclass init_table position */},
  {(bigint) standard___file___FStream___path},
  {(bigint) standard___file___FStream___file_stat},
  {(bigint) standard___file___FStream___init},
  {(bigint) 4 /* 50: Stdout < OFStream: superclass init_table position */},
  {(bigint) standard___file___OFStream___write_native},
  {(bigint) standard___file___OFStream___open},
  {(bigint) standard___file___OFStream___init},
  {(bigint) standard___file___OFStream___without_file},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 57: Stdout < IOS: superclass init_table position */},
  {(bigint) standard___file___OFStream___close},
  {(bigint) 3 /* 59: Stdout < OStream: superclass init_table position */},
  {(bigint) standard___file___OFStream___write},
  {(bigint) standard___file___OFStream___is_writable},
  {(bigint) 5 /* 62: Stdout < Stdout: superclass init_table position */},
  {(bigint) standard___file___Stdout___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Stdout::_path */
/* 3: Attribute Stdout::_file */
/* 4: Attribute Stdout::_writable */
static const char LOCATE_INIT_ATTRIBUTES__standard___file___Stdout[] = "init var of Stdout";
void INIT_ATTRIBUTES__standard___file___Stdout(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___file___Stdout;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/file.nit:54 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___file___FStream____path(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/file.nit:57 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___file___FStream____file(fra.me.REG[0]) = fra.me.REG[1];
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___file___Stdout(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_standard___file___Stdout;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___file___Stdout[] = "check new Stdout";
void CHECKNEW_standard___file___Stdout(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___file___Stdout;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___file___OFStream____writable(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_writable", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_Stdout_standard___file___Stdout___init[] = "new Stdout file::Stdout::init";
val_t NEW_Stdout_standard___file___Stdout___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[6] = {0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 173;
  fra.me.meth = LOCATE_NEW_Stdout_standard___file___Stdout___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  /* /home/jp/Projects-ssd/nit/lib/standard/file.nit:173 */
  fra.me.REG[0] = NEW_standard___file___Stdout();
  INIT_ATTRIBUTES__standard___file___Stdout(fra.me.REG[0]);
  standard___file___Stdout___init(fra.me.REG[0], init_table);
  CHECKNEW_standard___file___Stdout(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_standard___file___Stderr[64] = {
  {(bigint) 251 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "Stderr" /* 2: Class Name */},
  {(bigint) 3 /* 3: Stderr < Object: superclass typecheck marker */},
  {(bigint) 139 /* 4: Stderr < FStream: superclass typecheck marker */},
  {(bigint) 43 /* 5: Stderr < IOS: superclass typecheck marker */},
  {(bigint) 87 /* 6: Stderr < OStream: superclass typecheck marker */},
  {(bigint) 183 /* 7: Stderr < OFStream: superclass typecheck marker */},
  {(bigint) 251 /* 8: Stderr < Stderr: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 2 /* 17: Stderr < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 0 /* 46: Stderr < FStream: superclass init_table position */},
  {(bigint) standard___file___FStream___path},
  {(bigint) standard___file___FStream___file_stat},
  {(bigint) standard___file___FStream___init},
  {(bigint) 4 /* 50: Stderr < OFStream: superclass init_table position */},
  {(bigint) standard___file___OFStream___write_native},
  {(bigint) standard___file___OFStream___open},
  {(bigint) standard___file___OFStream___init},
  {(bigint) standard___file___OFStream___without_file},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 1 /* 57: Stderr < IOS: superclass init_table position */},
  {(bigint) standard___file___OFStream___close},
  {(bigint) 3 /* 59: Stderr < OStream: superclass init_table position */},
  {(bigint) standard___file___OFStream___write},
  {(bigint) standard___file___OFStream___is_writable},
  {(bigint) 5 /* 62: Stderr < Stderr: superclass init_table position */},
  {(bigint) standard___file___Stderr___init},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Stderr::_path */
/* 3: Attribute Stderr::_file */
/* 4: Attribute Stderr::_writable */
static const char LOCATE_INIT_ATTRIBUTES__standard___file___Stderr[] = "init var of Stderr";
void INIT_ATTRIBUTES__standard___file___Stderr(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___file___Stderr;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/file.nit:54 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___file___FStream____path(fra.me.REG[0]) = fra.me.REG[1];
  /* /home/jp/Projects-ssd/nit/lib/standard/file.nit:57 */
  fra.me.REG[1] = NIT_NULL;
  ATTR_standard___file___FStream____file(fra.me.REG[0]) = fra.me.REG[1];
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___file___Stderr(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_standard___file___Stderr;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___file___Stderr[] = "check new Stderr";
void CHECKNEW_standard___file___Stderr(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___file___Stderr;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___file___OFStream____writable(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "_writable", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_Stderr_standard___file___Stderr___init[] = "new Stderr file::Stderr::init";
val_t NEW_Stderr_standard___file___Stderr___init(void){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  int init_table[6] = {0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 182;
  fra.me.meth = LOCATE_NEW_Stderr_standard___file___Stderr___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  /* /home/jp/Projects-ssd/nit/lib/standard/file.nit:182 */
  fra.me.REG[0] = NEW_standard___file___Stderr();
  INIT_ATTRIBUTES__standard___file___Stderr(fra.me.REG[0]);
  standard___file___Stderr___init(fra.me.REG[0], init_table);
  CHECKNEW_standard___file___Stderr(fra.me.REG[0]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[0];
}
const classtable_elt_t VFT_standard___file___FileStat[53] = {
  {(bigint) -25 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "FileStat" /* 2: Class Name */},
  {(bigint) 3 /* 3: FileStat < Object: superclass typecheck marker */},
  {(bigint) -1 /* 4: FileStat < Pointer: superclass typecheck marker */},
  {(bigint) -25 /* 5: FileStat < FileStat: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 0 /* 17: FileStat < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 1 /* 46: FileStat < Pointer: superclass init_table position */},
  {(bigint) 2 /* 47: FileStat < FileStat: superclass init_table position */},
  {(bigint) standard___file___FileStat___mode},
  {(bigint) standard___file___FileStat___atime},
  {(bigint) standard___file___FileStat___ctime},
  {(bigint) standard___file___FileStat___mtime},
  {(bigint) standard___file___FileStat___size},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
val_t BOX_FileStat(void* val) {
  struct TBOX_FileStat *box = (struct TBOX_FileStat*)alloc(sizeof(struct TBOX_FileStat));
  box->vft = VFT_standard___file___FileStat;
  box->val = val;
  box->object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(box);
}
const classtable_elt_t VFT_standard___file___NativeFile[57] = {
  {(bigint) -21 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "NativeFile" /* 2: Class Name */},
  {(bigint) 3 /* 3: NativeFile < Object: superclass typecheck marker */},
  {(bigint) -1 /* 4: NativeFile < Pointer: superclass typecheck marker */},
  {(bigint) -21 /* 5: NativeFile < NativeFile: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 0 /* 17: NativeFile < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 1 /* 46: NativeFile < Pointer: superclass init_table position */},
  {(bigint) 2 /* 47: NativeFile < NativeFile: superclass init_table position */},
  {(bigint) standard___file___NativeFile___io_read},
  {(bigint) standard___file___NativeFile___io_write},
  {(bigint) standard___file___NativeFile___io_close},
  {(bigint) standard___file___NativeFile___file_stat},
  {(bigint) standard___file___NativeFile___io_open_read},
  {(bigint) standard___file___NativeFile___io_open_write},
  {(bigint) standard___file___NativeFile___native_stdin},
  {(bigint) standard___file___NativeFile___native_stdout},
  {(bigint) standard___file___NativeFile___native_stderr},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
val_t BOX_NativeFile(void* val) {
  struct TBOX_NativeFile *box = (struct TBOX_NativeFile*)alloc(sizeof(struct TBOX_NativeFile));
  box->vft = VFT_standard___file___NativeFile;
  box->val = val;
  box->object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(box);
}
const classtable_elt_t VFT_standard___exec___Process[57] = {
  {(bigint) 15 /* 0: Identity */},
  {(bigint) 3 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "Process" /* 2: Class Name */},
  {(bigint) 3 /* 3: Process < Object: superclass typecheck marker */},
  {(bigint) 15 /* 4: Process < Process: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 0 /* 17: Process < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 1 /* 46: Process < Process: superclass init_table position */},
  {(bigint) standard___exec___Process___id},
  {(bigint) standard___exec___Process___is_finished},
  {(bigint) standard___exec___Process___wait},
  {(bigint) standard___exec___Process___status},
  {(bigint) standard___exec___Process___init},
  {(bigint) standard___exec___Process___init_},
  {(bigint) standard___exec___Process___execute},
  {(bigint) standard___exec___Process___data},
  {(bigint) standard___exec___Process___data__eq},
  {(bigint) standard___exec___Process___basic_exec_execute},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute Process::@data */
static const char LOCATE_INIT_ATTRIBUTES__standard___exec___Process[] = "init var of Process";
void INIT_ATTRIBUTES__standard___exec___Process(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___exec___Process;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___exec___Process(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 3);
  obj->vft = (classtable_elt_t*)VFT_standard___exec___Process;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___exec___Process[] = "check new Process";
void CHECKNEW_standard___exec___Process(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___exec___Process;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___exec___Process_____atdata(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@data", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_Process_standard___exec___Process___init[] = "new Process exec::Process::init";
val_t NEW_Process_standard___exec___Process___init(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[2];} fra;
  val_t tmp;
  int init_table[2] = {0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 42;
  fra.me.meth = LOCATE_NEW_Process_standard___exec___Process___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 3;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[2] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = p1;
  /* /home/jp/Projects-ssd/nit/lib/standard/exec.nit:42 */
  fra.me.REG[2] = NEW_standard___exec___Process();
  INIT_ATTRIBUTES__standard___exec___Process(fra.me.REG[2]);
  standard___exec___Process___init(fra.me.REG[2], fra.me.REG[0], fra.me.REG[1], init_table);
  CHECKNEW_standard___exec___Process(fra.me.REG[2]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[2];
}
static const char LOCATE_NEW_Process_standard___exec___Process___init_[] = "new Process exec::Process::init_";
val_t NEW_Process_standard___exec___Process___init_(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[2] = {0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 48;
  fra.me.meth = LOCATE_NEW_Process_standard___exec___Process___init_;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/exec.nit:48 */
  fra.me.REG[1] = NEW_standard___exec___Process();
  INIT_ATTRIBUTES__standard___exec___Process(fra.me.REG[1]);
  standard___exec___Process___init_(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___exec___Process(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
static const char LOCATE_NEW_Process_standard___exec___Process___execute[] = "new Process exec::Process::execute";
val_t NEW_Process_standard___exec___Process___execute(val_t p0, val_t p1, val_t p2){
  struct {struct stack_frame_t me; val_t MORE_REG[2];} fra;
  val_t REGB0;
  val_t tmp;
  int init_table[2] = {0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 54;
  fra.me.meth = LOCATE_NEW_Process_standard___exec___Process___execute;
  fra.me.has_broke = 0;
  fra.me.REG_size = 3;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[2] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = p1;
  REGB0 = p2;
  /* /home/jp/Projects-ssd/nit/lib/standard/exec.nit:54 */
  fra.me.REG[2] = NEW_standard___exec___Process();
  INIT_ATTRIBUTES__standard___exec___Process(fra.me.REG[2]);
  standard___exec___Process___execute(fra.me.REG[2], fra.me.REG[0], fra.me.REG[1], REGB0, init_table);
  CHECKNEW_standard___exec___Process(fra.me.REG[2]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[2];
}
const classtable_elt_t VFT_standard___exec___IProcess[79] = {
  {(bigint) 195 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "IProcess" /* 2: Class Name */},
  {(bigint) 3 /* 3: IProcess < Object: superclass typecheck marker */},
  {(bigint) 15 /* 4: IProcess < Process: superclass typecheck marker */},
  {(bigint) 43 /* 5: IProcess < IOS: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 115 /* 7: IProcess < IStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 195 /* 9: IProcess < IProcess: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 0 /* 17: IProcess < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 1 /* 46: IProcess < Process: superclass init_table position */},
  {(bigint) standard___exec___Process___id},
  {(bigint) standard___exec___Process___is_finished},
  {(bigint) standard___exec___Process___wait},
  {(bigint) standard___exec___Process___status},
  {(bigint) standard___exec___Process___init},
  {(bigint) standard___exec___Process___init_},
  {(bigint) standard___exec___Process___execute},
  {(bigint) standard___exec___Process___data},
  {(bigint) standard___exec___Process___data__eq},
  {(bigint) standard___exec___Process___basic_exec_execute},
  {(bigint) 3 /* 57: IProcess < IOS: superclass init_table position */},
  {(bigint) standard___exec___IProcess___close},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 2 /* 62: IProcess < IStream: superclass init_table position */},
  {(bigint) standard___exec___IProcess___read_char},
  {(bigint) standard___stream___IStream___read},
  {(bigint) standard___stream___IStream___read_line},
  {(bigint) standard___stream___IStream___read_all},
  {(bigint) standard___stream___IStream___append_line_to},
  {(bigint) standard___exec___IProcess___eof},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 4 /* 74: IProcess < IProcess: superclass init_table position */},
  {(bigint) standard___exec___IProcess___stream_in},
  {(bigint) standard___exec___IProcess___stream_in__eq},
  {(bigint) standard___exec___IProcess___init},
  {(bigint) standard___exec___IProcess___init_},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute IProcess::@data */
/* Instance Hole :( */
/* 4: Attribute IProcess::@stream_in */
static const char LOCATE_INIT_ATTRIBUTES__standard___exec___IProcess[] = "init var of IProcess";
void INIT_ATTRIBUTES__standard___exec___IProcess(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___exec___IProcess;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___exec___IProcess(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_standard___exec___IProcess;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___exec___IProcess[] = "check new IProcess";
void CHECKNEW_standard___exec___IProcess(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___exec___IProcess;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___exec___IProcess_____atstream_in(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@stream_in", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___exec___Process_____atdata(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@data", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_IProcess_standard___exec___IProcess___init[] = "new IProcess exec::IProcess::init";
val_t NEW_IProcess_standard___exec___IProcess___init(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[2];} fra;
  val_t tmp;
  int init_table[5] = {0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 86;
  fra.me.meth = LOCATE_NEW_IProcess_standard___exec___IProcess___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 3;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[2] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = p1;
  /* /home/jp/Projects-ssd/nit/lib/standard/exec.nit:86 */
  fra.me.REG[2] = NEW_standard___exec___IProcess();
  INIT_ATTRIBUTES__standard___exec___IProcess(fra.me.REG[2]);
  standard___exec___IProcess___init(fra.me.REG[2], fra.me.REG[0], fra.me.REG[1], init_table);
  CHECKNEW_standard___exec___IProcess(fra.me.REG[2]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[2];
}
static const char LOCATE_NEW_IProcess_standard___exec___IProcess___init_[] = "new IProcess exec::IProcess::init_";
val_t NEW_IProcess_standard___exec___IProcess___init_(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[5] = {0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 92;
  fra.me.meth = LOCATE_NEW_IProcess_standard___exec___IProcess___init_;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/exec.nit:92 */
  fra.me.REG[1] = NEW_standard___exec___IProcess();
  INIT_ATTRIBUTES__standard___exec___IProcess(fra.me.REG[1]);
  standard___exec___IProcess___init_(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___exec___IProcess(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___exec___OProcess[74] = {
  {(bigint) 179 /* 0: Identity */},
  {(bigint) 4 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "OProcess" /* 2: Class Name */},
  {(bigint) 3 /* 3: OProcess < Object: superclass typecheck marker */},
  {(bigint) 15 /* 4: OProcess < Process: superclass typecheck marker */},
  {(bigint) 43 /* 5: OProcess < IOS: superclass typecheck marker */},
  {(bigint) 87 /* 6: OProcess < OStream: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {(bigint) 179 /* 8: OProcess < OProcess: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 0 /* 17: OProcess < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 1 /* 46: OProcess < Process: superclass init_table position */},
  {(bigint) standard___exec___Process___id},
  {(bigint) standard___exec___Process___is_finished},
  {(bigint) standard___exec___Process___wait},
  {(bigint) standard___exec___Process___status},
  {(bigint) standard___exec___Process___init},
  {(bigint) standard___exec___Process___init_},
  {(bigint) standard___exec___Process___execute},
  {(bigint) standard___exec___Process___data},
  {(bigint) standard___exec___Process___data__eq},
  {(bigint) standard___exec___Process___basic_exec_execute},
  {(bigint) 3 /* 57: OProcess < IOS: superclass init_table position */},
  {(bigint) standard___exec___OProcess___close},
  {(bigint) 2 /* 59: OProcess < OStream: superclass init_table position */},
  {(bigint) standard___exec___OProcess___write},
  {(bigint) standard___exec___OProcess___is_writable},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) 4 /* 69: OProcess < OProcess: superclass init_table position */},
  {(bigint) standard___exec___OProcess___stream_out},
  {(bigint) standard___exec___OProcess___stream_out__eq},
  {(bigint) standard___exec___OProcess___init},
  {(bigint) standard___exec___OProcess___init_},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute OProcess::@data */
/* 3: Attribute OProcess::@stream_out */
static const char LOCATE_INIT_ATTRIBUTES__standard___exec___OProcess[] = "init var of OProcess";
void INIT_ATTRIBUTES__standard___exec___OProcess(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___exec___OProcess;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___exec___OProcess(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 4);
  obj->vft = (classtable_elt_t*)VFT_standard___exec___OProcess;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___exec___OProcess[] = "check new OProcess";
void CHECKNEW_standard___exec___OProcess(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___exec___OProcess;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___exec___OProcess_____atstream_out(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@stream_out", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___exec___Process_____atdata(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@data", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_OProcess_standard___exec___OProcess___init[] = "new OProcess exec::OProcess::init";
val_t NEW_OProcess_standard___exec___OProcess___init(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[2];} fra;
  val_t tmp;
  int init_table[5] = {0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 111;
  fra.me.meth = LOCATE_NEW_OProcess_standard___exec___OProcess___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 3;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[2] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = p1;
  /* /home/jp/Projects-ssd/nit/lib/standard/exec.nit:111 */
  fra.me.REG[2] = NEW_standard___exec___OProcess();
  INIT_ATTRIBUTES__standard___exec___OProcess(fra.me.REG[2]);
  standard___exec___OProcess___init(fra.me.REG[2], fra.me.REG[0], fra.me.REG[1], init_table);
  CHECKNEW_standard___exec___OProcess(fra.me.REG[2]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[2];
}
static const char LOCATE_NEW_OProcess_standard___exec___OProcess___init_[] = "new OProcess exec::OProcess::init_";
val_t NEW_OProcess_standard___exec___OProcess___init_(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[5] = {0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 117;
  fra.me.meth = LOCATE_NEW_OProcess_standard___exec___OProcess___init_;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/exec.nit:117 */
  fra.me.REG[1] = NEW_standard___exec___OProcess();
  INIT_ATTRIBUTES__standard___exec___OProcess(fra.me.REG[1]);
  standard___exec___OProcess___init_(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___exec___OProcess(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___exec___IOProcess[83] = {
  {(bigint) 263 /* 0: Identity */},
  {(bigint) 5 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "IOProcess" /* 2: Class Name */},
  {(bigint) 3 /* 3: IOProcess < Object: superclass typecheck marker */},
  {(bigint) 15 /* 4: IOProcess < Process: superclass typecheck marker */},
  {(bigint) 43 /* 5: IOProcess < IOS: superclass typecheck marker */},
  {(bigint) 87 /* 6: IOProcess < OStream: superclass typecheck marker */},
  {(bigint) 115 /* 7: IOProcess < IStream: superclass typecheck marker */},
  {(bigint) 179 /* 8: IOProcess < OProcess: superclass typecheck marker */},
  {(bigint) 195 /* 9: IOProcess < IProcess: superclass typecheck marker */},
  {(bigint) 199 /* 10: IOProcess < IOStream: superclass typecheck marker */},
  {(bigint) 263 /* 11: IOProcess < IOProcess: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 0 /* 17: IOProcess < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 1 /* 46: IOProcess < Process: superclass init_table position */},
  {(bigint) standard___exec___Process___id},
  {(bigint) standard___exec___Process___is_finished},
  {(bigint) standard___exec___Process___wait},
  {(bigint) standard___exec___Process___status},
  {(bigint) standard___exec___Process___init},
  {(bigint) standard___exec___Process___init_},
  {(bigint) standard___exec___Process___execute},
  {(bigint) standard___exec___Process___data},
  {(bigint) standard___exec___Process___data__eq},
  {(bigint) standard___exec___Process___basic_exec_execute},
  {(bigint) 3 /* 57: IOProcess < IOS: superclass init_table position */},
  {(bigint) standard___exec___IOProcess___close},
  {(bigint) 5 /* 59: IOProcess < OStream: superclass init_table position */},
  {(bigint) standard___exec___OProcess___write},
  {(bigint) standard___exec___OProcess___is_writable},
  {(bigint) 2 /* 62: IOProcess < IStream: superclass init_table position */},
  {(bigint) standard___exec___IProcess___read_char},
  {(bigint) standard___stream___IStream___read},
  {(bigint) standard___stream___IStream___read_line},
  {(bigint) standard___stream___IStream___read_all},
  {(bigint) standard___stream___IStream___append_line_to},
  {(bigint) standard___exec___IProcess___eof},
  {(bigint) 6 /* 69: IOProcess < OProcess: superclass init_table position */},
  {(bigint) standard___exec___OProcess___stream_out},
  {(bigint) standard___exec___OProcess___stream_out__eq},
  {(bigint) standard___exec___OProcess___init},
  {(bigint) standard___exec___OProcess___init_},
  {(bigint) 4 /* 74: IOProcess < IProcess: superclass init_table position */},
  {(bigint) standard___exec___IProcess___stream_in},
  {(bigint) standard___exec___IProcess___stream_in__eq},
  {(bigint) standard___exec___IProcess___init},
  {(bigint) standard___exec___IProcess___init_},
  {(bigint) 7 /* 79: IOProcess < IOStream: superclass init_table position */},
  {(bigint) 8 /* 80: IOProcess < IOProcess: superclass init_table position */},
  {(bigint) standard___exec___IOProcess___init},
  {(bigint) standard___exec___IOProcess___init_},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
/* 2: Attribute IOProcess::@data */
/* 3: Attribute IOProcess::@stream_out */
/* 4: Attribute IOProcess::@stream_in */
static const char LOCATE_INIT_ATTRIBUTES__standard___exec___IOProcess[] = "init var of IOProcess";
void INIT_ATTRIBUTES__standard___exec___IOProcess(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_INIT_ATTRIBUTES__standard___exec___IOProcess;
  fra.me.has_broke = 0;
  fra.me.REG_size = 0;
  fra.me.nitni_local_ref_head = NULL;
  stack_frame_head = fra.me.prev;
}
val_t NEW_standard___exec___IOProcess(void)
{
  obj_t obj;
  obj = alloc(sizeof(val_t) * 5);
  obj->vft = (classtable_elt_t*)VFT_standard___exec___IOProcess;
  obj[1].object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(obj);
}
static const char LOCATE_CHECKNEW_standard___exec___IOProcess[] = "check new IOProcess";
void CHECKNEW_standard___exec___IOProcess(val_t p0){
  struct {struct stack_frame_t me;} fra;
  val_t REGB0;
  val_t tmp;
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 0;
  fra.me.meth = LOCATE_CHECKNEW_standard___exec___IOProcess;
  fra.me.has_broke = 0;
  fra.me.REG_size = 1;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[0] = p0;
  REGB0 = TAG_Bool(ATTR_standard___exec___IProcess_____atstream_in(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@stream_in", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___exec___Process_____atdata(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@data", LOCATE_test, 0);
  }
  REGB0 = TAG_Bool(ATTR_standard___exec___OProcess_____atstream_out(fra.me.REG[0])!=NIT_NULL);
  if (UNTAG_Bool(REGB0)) {
  } else {
    nit_abort("Uninitialized attribute %s", "@stream_out", LOCATE_test, 0);
  }
  stack_frame_head = fra.me.prev;
}
static const char LOCATE_NEW_IOProcess_standard___exec___IOProcess___init[] = "new IOProcess exec::IOProcess::init";
val_t NEW_IOProcess_standard___exec___IOProcess___init(val_t p0, val_t p1){
  struct {struct stack_frame_t me; val_t MORE_REG[2];} fra;
  val_t tmp;
  int init_table[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 136;
  fra.me.meth = LOCATE_NEW_IOProcess_standard___exec___IOProcess___init;
  fra.me.has_broke = 0;
  fra.me.REG_size = 3;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[2] = NIT_NULL;
  fra.me.REG[0] = p0;
  fra.me.REG[1] = p1;
  /* /home/jp/Projects-ssd/nit/lib/standard/exec.nit:136 */
  fra.me.REG[2] = NEW_standard___exec___IOProcess();
  INIT_ATTRIBUTES__standard___exec___IOProcess(fra.me.REG[2]);
  standard___exec___IOProcess___init(fra.me.REG[2], fra.me.REG[0], fra.me.REG[1], init_table);
  CHECKNEW_standard___exec___IOProcess(fra.me.REG[2]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[2];
}
static const char LOCATE_NEW_IOProcess_standard___exec___IOProcess___init_[] = "new IOProcess exec::IOProcess::init_";
val_t NEW_IOProcess_standard___exec___IOProcess___init_(val_t p0){
  struct {struct stack_frame_t me; val_t MORE_REG[1];} fra;
  val_t tmp;
  int init_table[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
  fra.me.prev = stack_frame_head; stack_frame_head = &fra.me;
  fra.me.file = LOCATE_test;
  fra.me.line = 143;
  fra.me.meth = LOCATE_NEW_IOProcess_standard___exec___IOProcess___init_;
  fra.me.has_broke = 0;
  fra.me.REG_size = 2;
  fra.me.nitni_local_ref_head = NULL;
  fra.me.REG[0] = NIT_NULL;
  fra.me.REG[1] = NIT_NULL;
  fra.me.REG[0] = p0;
  /* /home/jp/Projects-ssd/nit/lib/standard/exec.nit:143 */
  fra.me.REG[1] = NEW_standard___exec___IOProcess();
  INIT_ATTRIBUTES__standard___exec___IOProcess(fra.me.REG[1]);
  standard___exec___IOProcess___init_(fra.me.REG[1], fra.me.REG[0], init_table);
  CHECKNEW_standard___exec___IOProcess(fra.me.REG[1]);
  stack_frame_head = fra.me.prev;
  return fra.me.REG[1];
}
const classtable_elt_t VFT_standard___exec___NativeProcess[55] = {
  {(bigint) -17 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "NativeProcess" /* 2: Class Name */},
  {(bigint) 3 /* 3: NativeProcess < Object: superclass typecheck marker */},
  {(bigint) -1 /* 4: NativeProcess < Pointer: superclass typecheck marker */},
  {(bigint) -17 /* 5: NativeProcess < NativeProcess: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 0 /* 17: NativeProcess < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 1 /* 46: NativeProcess < Pointer: superclass init_table position */},
  {(bigint) 2 /* 47: NativeProcess < NativeProcess: superclass init_table position */},
  {(bigint) standard___exec___NativeProcess___id},
  {(bigint) standard___exec___NativeProcess___is_finished},
  {(bigint) standard___exec___NativeProcess___status},
  {(bigint) standard___exec___NativeProcess___wait},
  {(bigint) standard___exec___NativeProcess___in_fd},
  {(bigint) standard___exec___NativeProcess___out_fd},
  {(bigint) standard___exec___NativeProcess___err_fd},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
val_t BOX_NativeProcess(void* val) {
  struct TBOX_NativeProcess *box = (struct TBOX_NativeProcess*)alloc(sizeof(struct TBOX_NativeProcess));
  box->vft = VFT_standard___exec___NativeProcess;
  box->val = val;
  box->object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(box);
}
const classtable_elt_t VFT_event___EventBase[50] = {
  {(bigint) -29 /* 0: Identity */},
  {(bigint) 2 /* 1: Object size (-1 if a NativeArray)*/},
  {(bigint) "EventBase" /* 2: Class Name */},
  {(bigint) 3 /* 3: EventBase < Object: superclass typecheck marker */},
  {(bigint) -1 /* 4: EventBase < Pointer: superclass typecheck marker */},
  {(bigint) -29 /* 5: EventBase < EventBase: superclass typecheck marker */},
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {0} /* Class Hole :( */,
  {(bigint) standard___time___Object___get_time},
  {(bigint) 0 /* 17: EventBase < Object: superclass init_table position */},
  {(bigint) standard___kernel___Object___object_id},
  {(bigint) standard___kernel___Object___is_same_type},
  {(bigint) standard___kernel___Object_____eqeq},
  {(bigint) standard___kernel___Object_____neq},
  {(bigint) standard___kernel___Object___output},
  {(bigint) standard___kernel___Object___output_class_name},
  {(bigint) standard___kernel___Object___exit},
  {(bigint) standard___kernel___Object___sys},
  {(bigint) standard___file___Object___printn},
  {(bigint) standard___file___Object___print},
  {(bigint) standard___file___Object___getc},
  {(bigint) standard___file___Object___gets},
  {(bigint) standard___file___Object___stdin},
  {(bigint) standard___file___Object___stdout},
  {(bigint) standard___file___Object___stderr},
  {(bigint) standard___stream___Object___poll},
  {(bigint) standard___stream___Object___intern_poll},
  {(bigint) standard___string___Object___to_s},
  {(bigint) standard___string___Object___native_class_name},
  {(bigint) standard___string___Object___class_name},
  {(bigint) standard___string___Object___inspect},
  {(bigint) standard___string___Object___inspect_head},
  {(bigint) standard___string___Object___args},
  {(bigint) standard___hash___Object___hash},
  {(bigint) standard___math___Object___atan2},
  {(bigint) standard___math___Object___pi},
  {(bigint) standard___math___Object___srand_from},
  {(bigint) standard___math___Object___srand},
  {(bigint) 1 /* 46: EventBase < Pointer: superclass init_table position */},
  {(bigint) 2 /* 47: EventBase < EventBase: superclass init_table position */},
  {(bigint) event___EventBase___create_base},
  {(bigint) event___EventBase___dispatch},
};
/* 0: Pointer to the classtable */
/* 1: Object_id */
val_t BOX_EventBase(void* val) {
  struct TBOX_EventBase *box = (struct TBOX_EventBase*)alloc(sizeof(struct TBOX_EventBase));
  box->vft = VFT_event___EventBase;
  box->val = val;
  box->object_id = object_id_counter;
  object_id_counter = object_id_counter + 1;
  return OBJ2VAL(box);
}
classtable_t TAG2VFT[4] = {NULL, (const classtable_t)VFT_standard___kernel___Int, (const classtable_t)VFT_standard___kernel___Char, (const classtable_t)VFT_standard___kernel___Bool};
int main(int argc, char **argv) {
  prepare_signals();
  glob_argc = argc; glob_argv = argv;
  G_sys = NEW_standard___kernel___Sys();
  register_static_object(&G_sys);
  event___Sys___main(G_sys);
  return 0;
}
